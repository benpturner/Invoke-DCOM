<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PowerArgs</name>
    </assembly>
    <members>
        <member name="T:PowerArgs.ICommandLineArgumentsDefinitionFactory">
            <summary>
            An interface that defines a contract for creating command line argument definitions
            </summary>
        </member>
        <member name="M:PowerArgs.ICommandLineArgumentsDefinitionFactory.MakeDefinition(PowerArgs.CommandLineArgumentsDefinition)">
            <summary>
            Creates a definition given a base definition
            </summary>
            <param name="other">the base definition</param>
            <returns>the definition instance</returns>
        </member>
        <member name="M:PowerArgs.ICommandLineArgumentsDefinitionFactory.MakeDefinition">
            <summary>
            Creates a definition instance
            </summary>
            <returns>the definition instance</returns>
        </member>
        <member name="T:PowerArgs.CommandLineArgumentsDefinitionFactory">
            <summary>
            A helper class that lets you create definition factories from Funcs
            </summary>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinitionFactory.Create(System.Func{PowerArgs.CommandLineArgumentsDefinition,PowerArgs.CommandLineArgumentsDefinition})">
            <summary>
            Creates a factory that can create a definition from a base definition
            </summary>
            <param name="fromOtherImpl">An implementation that can create one definition from another</param>
            <returns>the factory</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinitionFactory.Create(System.Func{PowerArgs.CommandLineArgumentsDefinition})">
            <summary>
            Creates a factory that can create a definition
            </summary>
            <param name="fromNothingImpl">An implementation that can create a defunutuin</param>
            <returns>the factory</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinitionFactory.Create(System.Func{PowerArgs.CommandLineArgumentsDefinition,PowerArgs.CommandLineArgumentsDefinition},System.Func{PowerArgs.CommandLineArgumentsDefinition})">
            <summary>
            Creates a factory that can create a definition from a base definition or from nothing
            </summary>
            <param name="fromOtherImpl">An implementation that can create one definition from another</param>
            <param name="fromNothingImpl">An implementation that can create a defunutuin</param>
            <returns>the factory</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinitionFactory.MakeDefinition(PowerArgs.CommandLineArgumentsDefinition)">
            <summary>
            Creates a definition from a base using the provided Func
            </summary>
            <param name="other">the base definition</param>
            <returns>a definition</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinitionFactory.MakeDefinition">
            <summary>
            Creates a definition using the provided Func
            </summary>
            <returns>a definition</returns>
        </member>
        <member name="T:PowerArgs.Cli.CliHelper">
            <summary>
            A class that provides a framework for building interactive command line interfaces.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliHelper.Reader">
            <summary>
            Gets or sets the reader to use when reading input from the console
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.CliHelper.#ctor">
            <summary>
            Creates a new CLI object.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.CliHelper.Prompt(System.String,System.String[])">
            <summary>
            Prompts the user to select a value from a set of options.
            </summary>
            <param name="message">the prompt message</param>
            <param name="options">the options to choose from</param>
            <returns>The selected value</returns>
        </member>
        <member name="M:PowerArgs.Cli.CliHelper.Prompt(PowerArgs.ConsoleString,System.String[])">
            <summary>
            Prompts the user to select a value from a set of options.
            </summary>
            <param name="message">the prompt message</param>
            <param name="options">the options to choose from</param>
            <returns>The selected value</returns>
        </member>
        <member name="M:PowerArgs.Cli.CliHelper.IsUserSure(System.String)">
            <summary>
            Asks the user if they are sure about performing some operation and returns true if they indicate yes and
            false if they indicate no.
            </summary>
            <param name="about">The message to display.  'Are you sure?' will be apended.</param>
            <returns>true if they indicate yes and false if they indicate no.</returns>
        </member>
        <member name="M:PowerArgs.Cli.CliHelper.IsUserSure(PowerArgs.ConsoleString)">
            <summary>
            Asks the user if they are sure about performing some operation and returns true if they indicate yes and
            false if they indicate no.
            </summary>
            <param name="about">The message to display.  'Are you sure?' will be apended.</param>
            <returns>true if they indicate yes and false if they indicate no.</returns>
        </member>
        <member name="M:PowerArgs.Cli.CliHelper.PromptForLine(System.String)">
            <summary>
            Prompts the user for a line of input with the given message
            </summary>
            <param name="message">the prompt message</param>
            <returns>the input that the user entered</returns>
        </member>
        <member name="T:PowerArgs.Cli.PumpExceptionArgs">
            <summary>
            A class that defines the exception handling contract for a ConsoleApp
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PumpExceptionArgs.Exception">
            <summary>
            Gets the exception that a handler may handle
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PumpExceptionArgs.Handled">
            <summary>
            Gets or sets whether or not this exception has been handled by a handler.  Your event handler should set this to true
            if you want the pump to continue processing messages.  If no handler sets this to true then the pump thread will throw
            and the process will crash.
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.PumpMessage">
            <summary>
            A class that defines a message that can be executed by the message pump
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PumpMessage.Description">
            <summary>
            A description for this message, used for debugging
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.PumpMessage.#ctor(System.Action,System.String)">
            <summary>
            Creates a pump message with the given action and idempotency id.  
            </summary>
            <param name="a">The action to execute when this message is dequeued by a message pump</param>
            <param name="description">A description of this message that can be used for debugging purposes</param>
        </member>
        <member name="M:PowerArgs.Cli.PumpMessage.Execute">
            <summary>
            Executes the action associated with this message
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.PaintMessage">
            <summary>
            A message that indicates a paint request that gets processed differently from other message types to reduce
            the number of times the message pump processes paint requests for a console app
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.CliMessagePump">
            <summary>
            A class that is used to manage a CLI thread in a similar way that other platforms synchronize work
            on a UI thread
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliMessagePump.PumpException">
            <summary>
            An event that fires when a pump message throws an exception while executing.  Handlers can mark the exception as handled
            if they want to keep the pump running.  If no handler is registered or no handler marks the exception as handled then the
            pump thread will throw and the process will crash.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliMessagePump.IsRunning">
            <summary>
            A boolean that can be checked to see if the pump is currently running
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.#ctor(PowerArgs.IConsoleProvider,System.Action{System.ConsoleKeyInfo})">
            <summary>
            Creates a new message pump given a console to use for keyboard input
            </summary>
            <param name="console">the console to use for keyboard input</param>
            <param name="keyInputHandler">a key event handler to use to process keyboard input</param>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.QueueAction(System.Action)">
            <summary>
            Queues the given action for processing on the pump thread
            </summary>
            <param name="a">the action that will be processed in order on the pump thread</param>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.QueueAction(PowerArgs.Cli.PumpMessage)">
            <summary>
            Queues the given message for processing on the pump thread
            </summary>
            <param name="pumpMessage">the message that will be processed in order on the pump thread</param>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.SetInterval(System.Action,System.TimeSpan)">
            <summary>
            Schedules the given action for periodic processing by the message pump
            </summary>
            <param name="a">The action to schedule for periodic processing</param>
            <param name="interval">the execution interval for the action</param>
            <returns>A timer that can be passed to ClearInterval if you want to cancel the work</returns>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.SetTimeout(System.Action,System.TimeSpan)">
            <summary>
            Schedules the given action for a one time execution after the given period elapses
            </summary>
            <param name="a">The action to schedule</param>
            <param name="period">the period of time to wait before executing the action</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.ClearInterval(System.Threading.Timer)">
            <summary>
            Cancels the scheduled execution of a periodic action given the timer that was provided by SetInterval.  The timer will be disposed.
            </summary>
            <param name="t">the timer given by SetInterval</param>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.ClearTimeout(System.Threading.Timer)">
            <summary>
            Cancels the scheduled execution of a one time action given the timer that was provided by SetTimeout.  The timer will be disposed.
            </summary>
            <param name="t">The timer given by SetTimeout</param>
        </member>
        <member name="M:PowerArgs.Cli.CliMessagePump.Start">
            <summary>
            Starts the message pump which will begin processing messages
            </summary>
            <returns>A task that will complete when the message pump starts</returns>
        </member>
        <member name="T:PowerArgs.Cli.CliProgressBar">
            <summary>
            A utility that lets you display a progress bar on the console
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliProgressBar.BorderPen">
            <summary>
            Gets or sets the character to write when drawing the border
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliProgressBar.FillColor">
            <summary>
            Gets or sets the background color to use when filling in progress
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliProgressBar.MessageFillColor">
            <summary>
            Gets or sets the foreground color to use when filling in progress
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliProgressBar.Progress">
            <summary>
            Gets or sets the progress.  This value should be between 0 and 1, both inclusive.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliProgressBar.Width">
            <summary>
            Gets the width, in characters of the progress bar control.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliProgressBar.Message">
            <summary>
            Gets or sets the message to display inside of the progress bar
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.CliProgressBar.Console">
            <summary>
            Gets or sets the console to write to
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.#ctor(PowerArgs.ConsoleString,System.Nullable{System.Int32})">
            <summary>
            Creates a new progress bar given a width
            </summary>
            <param name="initialMessage">an initial message to display in the progress bar</param>
            <param name="width">the width to use or null to use the default width which is one third of the console buffer width</param>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.#ctor(System.String,System.Nullable{System.Int32})">
            <summary>
            Creates a new progress bar given a width
            </summary>
            <param name="initialMessage">an initial message to display in the progress bar</param>
            <param name="width">the width to use or null to use the default width which is one third of the console buffer width</param>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.Render">
            <summary>
            Renders the entire progress bar
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.RenderAndPollIndeterminate(System.Func{System.Boolean},System.TimeSpan)">
            <summary>
            Renders the progress bar and shows an indeterminate progress animation until the operation completes
            </summary>
            <param name="heartbeat">a function that should return true as long as you want to continue to block.  If you return false then this method will return.</param>
            <param name="pollingInterval">How fast you want the progress bar to call your heartbeat function</param>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.RenderUntilIndeterminate(System.Threading.Tasks.Task)">
            <summary>
            Renders the progress bar and shows an indeterminate progress animation until the Task completes.  This method will not
            start the task so it must be started somewhere else.
            </summary>
            <param name="workTask">the task to wait for.  This method will not start the task so it must be started somewhere else.</param>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.RenderUntilIndeterminate(System.Action)">
            <summary>
            Renders the progress bar and shows an indeterminate progress animation. Simultaneously, the work action is started. The bar will animate
            as long as the work action is running.
            </summary>
            <param name="workTask">the task to wait for</param>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.RenderAndPollDeterminate(System.Action,System.TimeSpan)">
            <summary>
            Renders the progress bar and automatically updates it on a polling interval. The method blocks until the progress reaches 1 or
            your poll action throws an OperationCancelledException, whichever comes first.  It is expected that you will update the progress
            via the poll action.  You can also update the message during the poll action.
            </summary>
            <param name="pollAction">An action to run on each polling interval</param>
            <param name="pollingInterval">The polling interval</param>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.Wipe">
            <summary>
            Clears the progress bar from the console and restores the console to the position it was in before drawing the progress bar
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.CliProgressBar.Update">
            <summary>
            Renders the middle portion of the progress bar that contains the message and progress fill.  You must have called Render() ahead of time for this
            to make sense.
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.FocusManager">
            <summary>
            A class that manages the focus of a CLI application
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.FocusManager.FocusContext">
            <summary>
            Data object used to capture the focus context on the stack
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.FocusManager.FocusContext.Controls">
            <summary>
            The controls being managed by this context
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.FocusManager.FocusContext.FocusIndex">
            <summary>
            The current focus index within this context
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.FocusContext.#ctor">
            <summary>
            Creates a new focus context
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.FocusManager.StackDepth">
            <summary>
            Gets the number of layers on the stack
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.FocusManager.GlobalKeyHandlers">
            <summary>
            Gets the keyboard manager that can be used to intercept keystrokes on the current layer
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.FocusManager.FocusedControl">
            <summary>
            Gets the currently focused control or null if there is no control with focus yet.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.#ctor">
            <summary>
            Initializes the focus manager
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.Add(PowerArgs.Cli.ConsoleControl)">
            <summary>
            Adds the current control to the current focus context
            </summary>
            <param name="c">The control to add</param>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.Remove(PowerArgs.Cli.ConsoleControl)">
            <summary>
            Removes the control from all focus contexts
            </summary>
            <param name="c">The control to remove</param>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.Push">
            <summary>
            Pushes a new focus context onto the stack.  This is useful, for example, when a dialog appears above all other
            controls and you want to limit focus to the dialog to acheive a modal affect.  You must remember to call pop
            when your context ends.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.Pop">
            <summary>
            Pops the current focus context.  This should be called if you've implemented a modal dialog like experience and your dialog
            has just closed.  Pop() will automatically restore focus on the previous context.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.TrySetFocus(PowerArgs.Cli.ConsoleControl)">
            <summary>
            Tries to set focus on the given control.
            </summary>
            <param name="newFocusControl">the control to focus.  </param>
            <returns>True if the focus was set or if it was already set, false if the control cannot be focused</returns>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.TryMoveFocus(System.Boolean)">
            <summary>
            Tries to move the focus forward or backwards
            </summary>
            <param name="forward">If true then the manager will try to move forwards, otherwise backwards</param>
            <returns>True if the focus moved, false otehrwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.TryRestoreFocus">
            <summary>
            Tries to restore the focus on the given context
            </summary>
            <returns>True if the focus changed, false otehrwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.FocusManager.ClearFocus">
            <summary>
            Clears the focus, but preserves the focus index
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.PowerArgsRichCommandLineReader">
            <summary>
            A customized version of the RichTextCommandLineReader that configures tab completion, history, and syntax highlighting for a given
            command line arguments definition.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PowerArgsRichCommandLineReader.ArgumentNameForeground">
            <summary>
            Gets or sets the foreground color to use when a valid argument name appears on the command line
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PowerArgsRichCommandLineReader.NumericForeground">
            <summary>
            Gets or sets the foreground color to use when a numeric value appears on the command line
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PowerArgsRichCommandLineReader.StringLiteralForeground">
            <summary>
            Gets or sets the foreground color to use when a double quoted string literal appears on the command line
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PowerArgsRichCommandLineReader.ActionForeground">
            <summary>
            Gets or sets the foregrund color to use when a valid action alias appears as the first token on the command line
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.PowerArgsRichCommandLineReader.Definition">
            <summary>
            Gets the definition that is used to configure the reader
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.PowerArgsRichCommandLineReader.#ctor(PowerArgs.CommandLineArgumentsDefinition,System.Collections.Generic.List{PowerArgs.ConsoleString})">
            <summary>
            Configures the reader for the given definition and history information.
            </summary>
            <param name="definition">The definition to use to configure the reader</param>
            <param name="history">previous command line values that the end user will be able to cycle through using the up and down arrows</param>
        </member>
        <member name="M:PowerArgs.Cli.PowerArgsRichCommandLineReader.TryTabComplete(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Implementation of tab completion that leverages tab completion sources that are registered with the target definition.
            </summary>
            <param name="cliContext">cintext used internally</param>
            <returns>true if a tab completion was successfully made, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.PowerArgsRichCommandLineReader.FindCurrentTokenArgument(PowerArgs.CommandLineAction,System.String,System.Boolean@,PowerArgs.CommandLineArgumentsDefinition)">
            <summary>
            A helper that detects the argument represented by the current token given a definition.  
            </summary>
            <param name="contextualAction">An action to inspect for a match if the current token does not match a global argument.  Pass null to only check global arguments.</param>
            <param name="currentToken">The token to inspect.  If you pass null you will get null back.</param>
            <param name="expectMatchingArg">This will be set to true if the current token starts with a '-' or a '/' meaning that the token was an argument indicator, even if it didn't match an argument in the definition.</param>
            <param name="def">The definition to inspect.  If null, the ambient definition will be used.  If there is no ambient definition and null is passed then this method throws a NullReferenceException.</param>
            <returns>An argument that is matched by the given token or null if there was no match</returns>
        </member>
        <member name="M:PowerArgs.Cli.PowerArgsRichCommandLineReader.FindContextualArgument(System.String,PowerArgs.CommandLineAction,PowerArgs.CommandLineArgumentsDefinition)">
            <summary>
            A helper that detects the argument represented by the current token given a definition.  
            </summary>
            <param name="previousToken">The token to inspect.  If you pass null you will get null back.</param>
            <param name="contextualAction">An action to inspect for a match if the current token does not match a global argument.  Pass null to only check global arguments.</param>
            <param name="def">The definition to inspect.  If null, the ambient definition will be used.  If there is no ambient definition and null is passed then this method throws a NullReferenceException.</param>
            <returns>An argument that is matched by the given token or null if there was no match</returns>
        </member>
        <member name="M:PowerArgs.Cli.PowerArgsRichCommandLineReader.FindPreviousNonWhitespaceToken(PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext)">
            <summary>
            Searches the reader's tokens for a non whitespace token that preceeds the current token
            </summary>
            <param name="readerContext">the reader context to inspect</param>
            <param name="highlighterContext">the highlighter context to inspect</param>
            <returns>a non whitespace token that preceeds the current token or null if no such token is found</returns>
        </member>
        <member name="M:PowerArgs.Cli.PowerArgsRichCommandLineReader.FindContextualAction(System.String,PowerArgs.CommandLineArgumentsDefinition)">
            <summary>
            Finds the action that matches the given token in the given definition
            </summary>
            <param name="firstToken">the token to test.  If you pass null you will get null back.</param>
            <param name="def">The definition to inspect.  If null, the ambient definition will be used.  If there is no ambient definition and null is passed then this method throws a NullReferenceException.</param>
            <returns>the action that matches the given token in the given definition or null if no such action is found</returns>
        </member>
        <member name="T:PowerArgs.Cli.ConsoleApp">
            <summary>
            A class representing a console application that uses a message pump to synchronize work on a UI thread
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.Current">
            <summary>
            Gets a reference to the current app running on this thread.  This will only be populated by the thread
            that is running the message pump (i.e. it will never be your main thread).
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.ControlAdded">
            <summary>
            An event that fires when a control is added to the visual tree
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.ControlRemoved">
            <summary>
            An event that fires when a control is removed from the visual tree
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.ApplicationStopped">
            <summary>
            An event that fired when the application stops, after the message pump is no longer running, and the console
            has been cleared of the app's visuals
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.Bitmap">
            <summary>
            Gets the bitmap that will be painted to the console
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.LayoutRoot">
            <summary>
            Gets the root panel that contains the controls being used by the app
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.MessagePump">
            <summary>
            Gets the message pump that is used to synchronize work
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.FocusManager">
            <summary>
            Gets the focus manager used to manage input focus
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.AutoFillOnConsoleResize">
            <summary>
            If set to true then the app will automatically update its layout to fill the entire window.  If false the app
            will not react to resizing, which means it may clip or wrap in unexpected ways when the window is resized.
            
            If you use the constructor that takes no parameters then this is set to true and assumes you want to take the
            whole window and respond to window size changes.  If you use the constructor that takes in coordinates and boudnds
            then it is set to false and it is assumed that you only want the app to live within those bounds
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.Theme">
            <summary>
            Gets or sets the theme
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleApp.SetFocusOnStart">
            <summary>
            Gets or set whether or not to give focus to a control when the app starts.  The default is true.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleApp.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new console app given a set of boundaries
            </summary>
            <param name="x">The left position on the target console to bound this app</param>
            <param name="y">The right position on the target console to bound this app</param>
            <param name="w">The width of the app</param>
            <param name="h">The height of the app</param>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleApp.#ctor">
            <summary>
            Creates a full screen console app that will automatically adjust its layout if the window size changes
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleApp.Start">
            <summary>
            Starts the app, asynchronously.
            </summary>
            <returns>A task that will complete when the app exits</returns>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleApp.Paint">
            <summary>
            Queues up a request to paint the app.  The system will dedupe multiple paint requests when there are multiple in the pump's work queue
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.ConsoleControl">
            <summary>
            A class that represents a visual element within a CLI application
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Id">
            <summary>
            An id that can be used for debugging.  It is not used for anything internally.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Focused">
            <summary>
            An event that fires after this control gets focus
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Unfocused">
            <summary>
            An event that fires after this control loses focus
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.AddedToVisualTree">
            <summary>
            An event that fires when this control is added to the visual tree of a ConsoleApp. 
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.BeforeAddedToVisualTree">
            <summary>
            An event that fires just before this control is added to the visual tree of a ConsoleApp
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.RemovedFromVisualTree">
            <summary>
            An event that fires when this control is removed from the visual tree of a ConsoleApp.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.BeforeRemovedFromVisualTree">
            <summary>
            An event that fires just before this control is removed from the visual tree of a ConsoleApp
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.KeyInputReceived">
            <summary>
            An event that fires when a key is pressed while this control has focus and the control has decided not to process
            the key press internally.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Application">
            <summary>
            Gets a reference to the application this control is a part of
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Parent">
            <summary>
            Gets a reference to this control's parent in the visual tree.  It will be null if this control is not in the visual tree 
            and also if this control is the root of the visual tree.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Background">
            <summary>
            Gets or sets the background color
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Foreground">
            <summary>
            Gets or sets the foreground color
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.TransparentBackground">
            <summary>
            Gets or sets whether or not this control should paint its background color or leave it transparent.  By default
            this value is false.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.Tag">
            <summary>
            An arbitrary reference to an object to associate with this control
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.IsVisible">
            <summary>
            Gets or sets whether or not this control is visible.  Invisible controls are still fully functional, except that they
            don't get painted
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.CanFocus">
            <summary>
            Gets or sets whether or not this control can accept focus.  By default this is set to true, but can
            be overridden by derived classes to be false by default.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleControl.HasFocus">
            <summary>
            Gets whether or not this control currently has focus
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleControl.#ctor">
            <summary>
            Creates a new ConsoleControl
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleControl.TryFocus">
            <summary>
            Tries to give this control focus. If the focus is in the visual tree, and is in the current focus layer, 
            and has it's CanFocus property to true then focus should be granted.
            </summary>
            <returns>True if focus was granted, false otherwise.  </returns>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleControl.TryUnfocus">
            <summary>
            Tries to unfocus this control.
            </summary>
            <returns>True if focus was cleared and moved.  False otherwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleControl.ToString">
            <summary>
            Gets the type and Id of this control
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.Cli.ConsoleControl.OnPaint(PowerArgs.Cli.ConsoleBitmap)">
            <summary>
            You should override this method if you are building a custom control, from scratch, and need to control
            every detail of the painting process.  If possible, prefer to create your custom control by deriving from
            ConsolePanel, which will let you assemble a new control from others.
            </summary>
            <param name="context">The scoped bitmap that you can paint on</param>
        </member>
        <member name="T:PowerArgs.Cli.LineChartViewModel">
            <summary>
            A view model to be used in conjunction with the LineChart control. 
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.LineChartViewModel.YMinimumOverride">
            <summary>
            If explicitly set then the minimum value of the Y axis will be forced to the value.  Otherwise, that value will be determined by the data.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.LineChartViewModel.YMaximumOverride">
            <summary>
            If explicitly set then the maximum value of the Y axis will be forced to the value.  Otherwise, that value will be determined by the data.
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.ObservableCollection`1">
            <summary>
            An observable list implementation
            </summary>
            <typeparam name="T">the type of elements this collection will contain</typeparam>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.BeforeAdded">
            <summary>
            Called before an item is added to the list
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.BeforeRemoved">
            <summary>
            Called after an item is removed from the list
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.Added">
            <summary>
            Called when an element is added to this list
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.Removed">
            <summary>
            Called when an element is removed from this list
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.Changed">
            <summary>
            Called whenever this list changes.  You may receive one event for multiple changes
            if the changes were atomic (e.g. after calling Clear()).
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.#ctor">
            <summary>
            Initialized the collection
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.FireAdded(`0)">
            <summary>
            Fires the Added event for the given item
            </summary>
            <param name="item">The item that was added</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.FireRemoved(`0)">
            <summary>
            Fired the Removed event for the given item
            </summary>
            <param name="item">The item that was removed</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.IndexOf(`0)">
            <summary>
            Returns the index of the given item in the list
            </summary>
            <param name="item">the item to look for</param>
            <returns>the index or a negative number if the element is not in the list</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.Insert(System.Int32,`0)">
            <summary>
            Inserts the given item into the list at the specified position
            </summary>
            <param name="index">the index to insert the item into</param>
            <param name="item">the item to insert</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index
            </summary>
            <param name="index">the index of the item to remove</param>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.Item(System.Int32)">
            <summary>
            Gets or sets the value at a particular index
            </summary>
            <param name="index">the index of the item to get or set</param>
            <returns>the value at a particular index</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.Add(`0)">
            <summary>
            Adds the given item to the list
            </summary>
            <param name="item">the item to add</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.Clear">
            <summary>
            Removes all items from the collection
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.Contains(`0)">
            <summary>
            Tests to see if the list contains the given item
            </summary>
            <param name="item">the item to look for</param>
            <returns>true if the list contains the given item, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies values from this list into the given array starting at the given index in the destination
            </summary>
            <param name="array">the destination array</param>
            <param name="arrayIndex">the index in the destination array to start the copy</param>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.Count">
            <summary>
            Gets the number of items in the list
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableCollection`1.IsReadOnly">
            <summary>
            Always returns false
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.Remove(`0)">
            <summary>
            Removes the given item from the list
            </summary>
            <param name="item">the item to remove</param>
            <returns>true if an item was removed, false if the item was not found in the list</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.GetEnumerator">
            <summary>
            Gets an enumerator for this list
            </summary>
            <returns>an enumerator for this list</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for this list
            </summary>
            <returns>an enumerator for this list</returns>
        </member>
        <member name="T:PowerArgs.Cli.ObservableObject">
            <summary>
            A class that makes it easy to define an object with observable properties
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ObservableObject.AnyProperty">
            <summary>
            Subscribe or synchronize using this key to receive notifications when any property changes
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ObservableObject.SuppressEqualChanges">
            <summary>
            Set to true if you want to suppress notification events for properties that get set to their existing values.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.#ctor">
            <summary>
            Creates a new bag and optionally sets the notifier object.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.Get``1(System.String)">
            <summary>
            This should be called by a property getter to get the value
            </summary>
            <typeparam name="T">The type of property to get</typeparam>
            <param name="name">The name of the property to get</param>
            <returns>The property's current value</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.Set``1(``0,System.String)">
            <summary>
            This should be called by a property getter to set the value.
            </summary>
            <typeparam name="T">The type of property to set</typeparam>
            <param name="value">The value to set</param>
            <param name="name">The name of the property to set</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.SubscribeUnmanaged(System.String,System.Action)">
            <summary>
            Subscribes to be notified when the given property changes.
            </summary>
            <param name="propertyName">The name of the property to subscribe to or ObservableObject.AnyProperty if you want to be notified of any property change.</param>
            <param name="handler">The action to call for notifications</param>
            <returns>A subscription that will receive notifications until it is disposed</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.SubscribeForLifetime(System.String,System.Action,PowerArgs.Cli.LifetimeManager)">
            <summary>
            Subscribes to be notified when the given property changes.  The subscription expires when
            the given lifetime manager's lifetime ends.
            </summary>
            <param name="propertyName">The name of the property to subscribe to or ObservableObject.AnyProperty if you want to be notified of any property change.</param>
            <param name="handler">The action to call for notifications</param>
            <param name="lifetimeManager">the lifetime manager that determines when the subscription ends</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.SynchronizeUnmanaged(System.String,System.Action)">
            <summary>
            Subscribes to be notified when the given property changes and also fires an initial notification immediately.
            </summary>
            <param name="propertyName">The name of the property to subscribe to or ObservableObject.AnyProperty if you want to be notified of any property change.</param>
            <param name="handler">The action to call for notifications</param>
            <returns>A subscription that will receive notifications until it is disposed</returns>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.SynchronizeForLifetime(System.String,System.Action,PowerArgs.Cli.LifetimeManager)">
            <summary>
            Subscribes to be notified when the given property changes and also fires an initial notification.  The subscription expires when
            the given lifetime manager's lifetime ends.
            </summary>
            <param name="propertyName">The name of the property to subscribe to or ObservableObject.AnyProperty if you want to be notified of any property change.</param>
            <param name="handler">The action to call for notifications</param>
            <param name="lifetimeManager">the lifetime manager that determines when the subscription ends</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.FirePropertyChanged(System.String)">
            <summary>
            Fires the PropertyChanged event with the given property name.
            </summary>
            <param name="propertyName">the name of the property that changed</param>
        </member>
        <member name="M:PowerArgs.Cli.ObservableObject.EqualsSafe(System.Object,System.Object)">
            <summary>
            A generic equals implementation that allows nulls to be passed for either parameter.  Objects should not call this from
            within their own equals method since that will cause a stack overflow.  The Equals() functions do not get called if the two
            inputs reference the same object.
            </summary>
            <param name="a">The first object to test</param>
            <param name="b">The second object to test</param>
            <returns>True if the values are equal, false otherwise.</returns>
        </member>
        <member name="T:PowerArgs.Cli.ConsoleHistoryManager">
            <summary>
            A class that stores and manages command line history that is used by the up and down arrow keys handler to let users cycle through historical command lines.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ConsoleHistoryManager.Values">
            <summary>
            Gets the list of values that can be cycled through
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.IContextAssistProvider">
            <summary>
            An interface you can implement to inject custom contextually aware command line helpers.  PowerArgs provides a few out of the box, but
            you are free to create your own. 
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.IContextAssistProvider.CanAssist(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Determines if this assistant provider can assist given context about what the user has typed on the command line so far.
            </summary>
            <param name="context">context about what the user has typed on the command line so far</param>
            <returns>true if your provider can assist, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.IContextAssistProvider.DrawMenu(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Draws the provider's menu.  You can be sure that PowerArgs has called CanAssist and received a value of true before it will call this
            method.
            </summary>
            <param name="context">context about what the user has typed on the command line so far</param>
            <returns>You can choose to return a result right away if you handle keyboard input manually in your drawing function</returns>
        </member>
        <member name="M:PowerArgs.Cli.IContextAssistProvider.ClearMenu(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Clears the provider's menu.  This gets called if the user cancel's the assistance via the escape key or if your
            provider returns a terminal result when handling keyboard input.
            </summary>
            <param name="context">context about what the user has typed on the command line so far</param>
        </member>
        <member name="M:PowerArgs.Cli.IContextAssistProvider.OnKeyboardInput(PowerArgs.Cli.RichCommandLineContext,System.ConsoleKeyInfo)">
            <summary>
            Called when your provider is visible and the user provides keyboard input.  All keys will be forwarded to your provider.  Unless you
            have a really good reason you should return a cancel result when you encounter the escape key and you should use the enter key as your
            selection mechanism.  If you returned a terminating result in your DrawMenu() function then this will never get called.
            </summary>
            <param name="context">context about what the user has typed on the command line so far</param>
            <param name="keyPress">Information about the key that was pressed</param>
            <returns>You should return the appropriate result based on how you've decided to handle the keypress.</returns>
        </member>
        <member name="T:PowerArgs.Cli.ContextAssistPicker">
            <summary>
            A context assist provider that lets the user select from a fixed set of options
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistPicker.SupportsAsync">
            <summary>
            returns false, always
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistPicker.Options">
            <summary>
            The options the user can choose from
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistPicker.CanAssist(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Returns true if there is at least one option, false otherwise.
            </summary>
            <param name="context">context about the parent reader</param>
            <returns>true if there is at least one option, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistPicker.#ctor">
            <summary>
            initialized the picker
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistPicker.GetResults(System.String)">
            <summary>
            returns all options that contain the given search string, ignoring case
            </summary>
            <param name="searchString">the search string</param>
            <returns>all options that contain the given search string, ignoring case</returns>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistPicker.GetResultsAsync(System.String)">
            <summary>
            Not implemented
            </summary>
            <param name="searchString">Not implemented</param>
            <returns>Not implemented</returns>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistPicker.Pick(PowerArgs.IConsoleProvider,System.Boolean)">
            <summary>
            Lets the user pick from the set of options.
            </summary>
            <param name="console">optionally provide a custom console implementation</param>
            <param name="allowCancel">if true, users can cancel picking by pressing the escape key.  If false, the escape key does nothing.</param>
            <returns>A valid selection or null if the search was cancelled.</returns>
        </member>
        <member name="T:PowerArgs.Cli.MultiContextAssistProvider">
            <summary>
            A context assist provider that wraps a collection of inner providers.  
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.MultiContextAssistProvider.Providers">
            <summary>
            The inner providers that will be cycled through whenever assistance is requested
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.MultiContextAssistProvider.CurrentProvider">
            <summary>
            Gets the current provider
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.MultiContextAssistProvider.#ctor">
            <summary>
            Initializes the provider
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.MultiContextAssistProvider.DrawMenu(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Draws the current provider's menu
            </summary>
            <param name="context">passed to the current provider</param>
            <returns>the inner provider's result</returns>
        </member>
        <member name="M:PowerArgs.Cli.MultiContextAssistProvider.ClearMenu(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Clears the current provider's menu
            </summary>
            <param name="context">passed to the current provider</param>
        </member>
        <member name="M:PowerArgs.Cli.MultiContextAssistProvider.OnKeyboardInput(PowerArgs.Cli.RichCommandLineContext,System.ConsoleKeyInfo)">
            <summary>
            Passes the keyboard input to the current provider
            </summary>
            <param name="context">passed to the current provider</param>
            <param name="keyPress">passed to the current provider</param>
            <returns>the current provider's result</returns>
        </member>
        <member name="M:PowerArgs.Cli.MultiContextAssistProvider.CanAssist(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Cycles through the inner providers and calls their CanAssist method until one of them returns true.
            If that happens, the first to return true is promoted to be the current provider.
            </summary>
            <param name="context">passed to inner providers to see if they can assist</param>
            <returns>true if one of the inner providers can assist, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Cli.ContextAssistResultStatusCode">
            <summary>
            Status codes that content assist providers can return
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ContextAssistResultStatusCode.NoOp">
            <summary>
            Indicates that no progress was made and that the assist provider should continue to accept keyboard input.
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ContextAssistResultStatusCode.Success">
            <summary>
            Indicates that progress was made and that the value of the result object's NewBuffer property should be used to replace the parent reader's buffer.
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ContextAssistResultStatusCode.Cancel">
            <summary>
            Indicates that the user or system cancelled the assist provider and the parent buffer should not be modified. 
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.ContextAssistResult">
            <summary>
            A class that represents a result that an IContentAssistProvider returns to a parent reader.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistResult.StatusCode">
            <summary>
            Gets status code for this result
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistResult.NewBuffer">
            <summary>
            Gets the new buffer to apply to the parent reader.  This is only applicable for a status code of Success.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistResult.ConsoleRefreshLeftOffset">
            <summary>
            Gets the offset to apply to the cursor position.  This is only applicable for a status code of Success.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistResult.IsTerminal">
            <summary>
            Returns true if this result should stop the current assist provider, false otherwise
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ContextAssistResult.NoOp">
            <summary>
            A result that indicates that no result is ready and that the assist provider should continue to accept keyboard input
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.ContextAssistResult.Cancel">
            <summary>
            A result that indicates that either the user or the system wants to stop the assist provider without making any changes to the 
            parent reader
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistResult.CreateCustomResult(System.Collections.Generic.List{PowerArgs.ConsoleCharacter},System.Int32)">
            <summary>
            Creates a custom result that manually replaces the entire parent reader's buffer.
            </summary>
            <param name="newBuffer">the new buffer to apply to the parent reader</param>
            <param name="consoleRefreshLeftOffset">The relative offset to apply to the current cursor position</param>
            <returns>a custom result that manually replaces the entire parent reader's buffer</returns>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistResult.CreateInsertResult(PowerArgs.Cli.RichCommandLineContext,PowerArgs.ConsoleString)">
            <summary>
            Creates a result that replaces the current token with the given selection.
            </summary>
            <param name="context">Context from the parent reader</param>
            <param name="selection">The selection string to insert</param>
            <returns>a result that replaces the current token with the given selection</returns>
        </member>
        <member name="T:PowerArgs.Cli.ContextAssistSearchResult">
            <summary>
            A class that represents a search result that can be selected by the ContextAssistSearch context assist provider.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistSearchResult.DisplayText">
            <summary>
            Gets the text to display in the results view.  This text is also used when this result is inserted into the parent reader
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistSearchResult.RichDisplayText">
            <summary>
            Gets the text to display in the results view.  This text is also used when this result is inserted into the parent reader
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ContextAssistSearchResult.ResultValue">
            <summary>
            Gets a plain old .NET object that represents the underlying result value.  In many cases this will be the same as the display text.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistSearchResult.FromString(System.String)">
            <summary>
            Creates a string result where the display text and value are the same object.
            </summary>
            <param name="stringValue">the result string</param>
            <returns>a search result</returns>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistSearchResult.FromConsoleString(PowerArgs.ConsoleString)">
            <summary>
            Creates a string result where the display text and value are the same object.
            </summary>
            <param name="stringValue">the result string</param>
            <returns>a search result</returns>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistSearchResult.FromObject(System.Object,System.String)">
            <summary>
            Creates a search result from an object, given an optional display value.
            </summary>
            <param name="value">The object to use as a result.</param>
            <param name="displayText">The display text for the result.  If null, the value's ToString() method will be called</param>
            <returns>a search result</returns>
        </member>
        <member name="M:PowerArgs.Cli.ContextAssistSearchResult.FromObject(System.Object,PowerArgs.ConsoleString)">
            <summary>
            Creates a search result from an object, given an optional display value.
            </summary>
            <param name="value">The object to use as a result.</param>
            <param name="displayText">The display text for the result.  If null, the value's ToString() method will be called</param>
            <returns>a search result</returns>
        </member>
        <member name="T:PowerArgs.Cli.RichCommandLineContext">
            <summary>
            A class that provides context for consumers of the RichTextCommandLineReader
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.DisableConsoleRefresh">
            <summary>
            For now this is here to support the mode when this context is used within a ConsoleApp.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.Console">
            <summary>
            Gets the console implementation that's being used to read the input
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.Buffer">
            <summary>
            The current buffer of characters on the command line.  If you manipulate the buffer during tab completion or other key handling
            then you should call RefreshConsole() or ReplaceConsole() so that the updates get reflected.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.KeyPressed">
            <summary>
            The key that was last pressed and is currently being processed.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.Intercept">
            <summary>
            You should set this flag if your handler is goind to take care of updating the console manually.  If false, the reader will
            apply the keypress to the console automatically.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.HistoryManager">
            <summary>
            Gets a reference to the history manager that contains previous command line values.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.CharacterToWrite">
            <summary>
            Gets a reference to the character that is about to be written
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.IsFinished">
            <summary>
            You should set this to true if you want to commit the line being read.  Typically this is only set by the enter key handler.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.ConsoleStartLeft">
            <summary>
            Gets the value of the cursor left position when the read operation began
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.ConsoleStartTop">
            <summary>
            Gets the value of the cursor top position when the read operation began
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.BufferPosition">
            <summary>
            Gets the cursor position, relative to the buffer as opposed to the absolute left and right positions within the console.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.Tokens">
            <summary>
            Gets the tokens that were last parsed.  This is not always populated for you since not all key handlers require tokenizing
            the input.  If you need this in your handler then first call RefreshTokenInfo().
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.Tokenizer">
            <summary>
            Gets the tokenizer used to tokenize command line input.  By default it knows how to handle string literals and escape
            sequences that are appropriate for a command line.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.CurrentToken">
            <summary>
            Gets the token that maps to the current BufferPosition. This is not always populated for you since not all key handlers require tokenizing
            the input.  If you need this in your handler then first call RefreshTokenInfo().
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.CurrentTokenIndex">
            <summary>
            Gets the index of the current token within the list of tokens.  This is not always populated for you since not all key handlers require tokenizing
            the input.  If you need this in your handler then first call RefreshTokenInfo().
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichCommandLineContext.PreviousNonWhitespaceToken">
            <summary>
            Gets the non whitespace token that comes immediately before the current token, or null if there is no previous non whitespace token.  This is not always populated for you since not all key handlers require tokenizing
            the input.  If you need this in your handler then first call RefreshTokenInfo().
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.RichCommandLineContext.GetBufferSubstringFromToken(PowerArgs.Token)">
            <summary>
            Returns the portion of the buffer represented by the given token
            </summary>
            <param name="t">the token whose position to use to look into the buffer</param>
            <returns>the portion of the buffer represented by the given token</returns>
        </member>
        <member name="M:PowerArgs.Cli.RichCommandLineContext.ClearConsole">
            <summary>
            Clears the console
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.RichCommandLineContext.RefreshConsole(System.Int32,System.Int32)">
            <summary>
            Rewrites the console using the latest values in the Buffer, preserving the cursor position with an optional adjustment.  
            </summary>
            <param name="leftAdjust">Adjusts the left cursor position by the desired amound.  If you want the cursor to stay where it was then use 0.</param>
            <param name="topAdjust">Adjusts the top cursor position by the desired amound.  If you want the cursor to stay where it was then use 0.</param>
        </member>
        <member name="M:PowerArgs.Cli.RichCommandLineContext.ReplaceConsole(PowerArgs.ConsoleString)">
            <summary>
            Rewrites the console using the latest values in the Buffer and moves the cursor to the end of the line.
            </summary>
            <param name="newBuffer">The new line of text that will replace the current buffer.</param>
        </member>
        <member name="M:PowerArgs.Cli.RichCommandLineContext.RefreshTokenInfo(System.Boolean)">
            <summary>
            Runs the tokenizer if it hasn't already been run on the current key press.  You can pass a force flag if you want to
            force the tokenizer to run.  You would need to do this only if you've manually changed the buffer within your handler.
            </summary>
            <param name="force">If true, then the tokenizer is run no matter what.  If false, the tokenizer only runs if it hasn't yet run on this keystroke.</param>
        </member>
        <member name="M:PowerArgs.Cli.RichCommandLineContext.WriteCharacterForPressedKey">
            <summary>
            Takes the value of KeyPressed.KeyChar and writes it to the console in the current buffer position.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.RichCommandLineContext.CompleteCurrentToken(PowerArgs.Token,PowerArgs.ConsoleString)">
            <summary>
            Performs an auto complete of the given token.
            </summary>
            <param name="currentToken">the token to complete</param>
            <param name="completion">the completed token.  Note that it is not required that the completion string starts with the current token value, though it usually does.</param>
        </member>
        <member name="T:PowerArgs.Cli.IKeyHandler">
            <summary>
            An interface that defines the contract for how key presses get handled within the RichTextCommandLineReader context
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.IKeyHandler.KeysHandled">
            <summary>
            Gets the list of keys that are handled by this handler
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.IKeyHandler.Handle(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            This will be called when the user presses one of the keys defined by KeysHandled.
            </summary>
            <param name="context">Context that lets you inspect the current state of the command line and modify it</param>
        </member>
        <member name="T:PowerArgs.Cli.KeyHandler">
            <summary>
            A class that lets you dynamically create key handlers
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.KeyHandler.KeysHandled">
            <summary>
            Gets the keys handled by this handler
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.KeyHandler.Handler">
            <summary>
            gets the action that implements the handler functionality
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.KeyHandler.FromAction(System.Action{PowerArgs.Cli.RichCommandLineContext},System.ConsoleKey[])">
            <summary>
            Creates a key handler from the given action
            </summary>
            <param name="handler">the handler action code</param>
            <param name="keysHandled">the keys that this handler handles</param>
            <returns>the handler</returns>
        </member>
        <member name="M:PowerArgs.Cli.KeyHandler.Handle(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Calls the handler action code
            </summary>
            <param name="context">context from the parent reader</param>
        </member>
        <member name="T:PowerArgs.Cli.ITabCompletionHandler">
            <summary>
            An interface that defines the contract for tab completion in the context of a RichTextCommandLineReader.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ITabCompletionHandler.TryTabComplete(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            When the user presses the tab key in the context of a RichTextCommandLineReader's read operation, registered
            tab completion handlers will have this method invoked, in order.  Handlers should return true if they've updated the
            context by performing a successful tab completion.  They should return false if they have not.  Processing stops as soon
            as any handler returns true.
            </summary>
            <param name="context">Context you can use to inspect the current command line to perform tab completion</param>
            <returns>true if you've updated the context and performed a successful tab completion, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Cli.TabKeyHandler">
            <summary>
            The built in tab key handler
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.TabKeyHandler.KeysHandled">
            <summary>
            gets a collection that only contains ConsoleKey.Tab
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.TabKeyHandler.ThrowOnTabCompletionHandlerException">
            <summary>
            Gets or sets whether or not to propagate exceptions thrown by tab completion highlighters.  The default is false.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.TabKeyHandler.TabCompletionHandlers">
            <summary>
            Gets the list of registered tab completion handlers.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.TabKeyHandler.#ctor">
            <summary>
            Creates a new tab key handler.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.TabKeyHandler.Handle(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Handles the tab key by calling all registered tab completion handlers.
            </summary>
            <param name="context">Context that can be used to inspect the current command line to perform tab completion</param>
        </member>
        <member name="P:PowerArgs.Cli.RichTextEditor.Highlighter">
            <summary>
            Gets or sets the highlighter used to highlight tokens as the user types
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextEditor.TabHandler">
            <summary>
            Gets the tab hey handler.  This will let you plug in custom tab completion logic.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextEditor.RegisteredKeyHandlers">
            <summary>
            Gets a read only collection of currently registered key handlers.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextEditor.ContextAssistProvider">
            <summary>
            Gets or sets the context assit provider that should be used for this reader
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.RichTextEditor.RegisterHandler(PowerArgs.Cli.IKeyHandler)">
            <summary>
            Lets you register a custom key handler. You are responsible for ensuring that each key is only handled by one handler.  This method will throw if
            you try to add a duplicate key handler.
            </summary>
            <param name="handler">The handler to register</param>
        </member>
        <member name="T:PowerArgs.Cli.RichTextCommandLineReader">
            <summary>
            A utility that lets you prompt a console user for input in an interactive way.  It provides hooks for tab completion, syntax highlighting, history management via the up and down arrows, etc.
            </summary>
        </member>
        <member name="E:PowerArgs.Cli.RichTextCommandLineReader.AfterReadKey">
            <summary>
            An event that fires after the user enters a key.  The event will not fire for
            terminating keystrokes
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.Console">
            <summary>
            The console implementation to target
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.RegisteredKeyHandlers">
            <summary>
            Gets a read only collection of currently registered key handlers.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.Highlighter">
            <summary>
            Gets or sets the highlighter used to highlight tokens as the user types
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.TabHandler">
            <summary>
            Gets the tab hey handler.  This will let you plug in custom tab completion logic.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.ContextAssistProvider">
            <summary>
            Gets or sets the context assit provider that should be used for this reader
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.HistoryManager">
            <summary>
            Gets the history manager.  This will let you add your historical command line values so that end users can cycle through them using the up and down arrows.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.ThrowOnSyntaxHighlightException">
            <summary>
            Gets or sets whether or not to propagate exceptions thrown by syntax highlighters.  The default is false.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.RichTextCommandLineReader.SyncLock">
            <summary>
            Gets or sets the object to use to synchronize reading with other threads that are interacting with the console
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.RichTextCommandLineReader.#ctor">
            <summary>
            Creates a new reader.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.RichTextCommandLineReader.RegisterHandler(PowerArgs.Cli.IKeyHandler)">
            <summary>
            Lets you register a custom key handler. You are responsible for ensuring that each key is only handled by one handler.  This method will throw if
            you try to add a duplicate key handler.
            </summary>
            <param name="handler">The handler to register</param>
        </member>
        <member name="M:PowerArgs.Cli.RichTextCommandLineReader.UnregisterHandler(PowerArgs.Cli.IKeyHandler)">
            <summary>
            Unregisters the given key handler from the reader.  You should only do this if you're planning on overriding the default handlers, and you should do so
            with caution.
            </summary>
            <param name="handler">The handler to unregister</param>
        </member>
        <member name="M:PowerArgs.Cli.RichTextCommandLineReader.UnregisterHandler(System.ConsoleKey)">
            <summary>
            Unregisters the handler for the given key
            </summary>
            <param name="key">the key to unregister</param>
            <returns>true if there was a handler registered and removed, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.Cli.RichTextCommandLineReader.ReadCommandLine(PowerArgs.ConsoleString)">
            <summary>
            Reads a line of text from the console and converts it into a string array that has accounted for escape sequences and quoted string literals.
            </summary>
            <param name="initialBuffer">Optionally seed the prompt with an initial value that the end user can modify</param>
            <returns>the command line that was read</returns>
        </member>
        <member name="M:PowerArgs.Cli.RichTextCommandLineReader.ReadLine(PowerArgs.ConsoleString)">
            <summary>
            Reads a line of text from the console.  Any interactions you've configured before calling this method will be in effect.
            </summary>
            <param name="initialBuffer">Optionally seed the prompt with an initial value that the end user can modify</param>
            <returns>a line of text from the console</returns>
        </member>
        <member name="M:PowerArgs.Cli.RichTextCommandLineReader.IsWriteable(System.ConsoleKeyInfo)">
            <summary>
            Determines if the given key is writable text
            </summary>
            <param name="info">the key info</param>
            <returns>true if the given key is writable text, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Cli.HighlighterContext">
            <summary>
            Context about a token that helps determine if it should be highlighted
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.HighlighterContext.CurrentTokenIndex">
            <summary>
            The index of this token within the set of tokens in the base context
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.HighlighterContext.CurrentToken">
            <summary>
            The token that may or may not need to be highlighted
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.HighlighterContext.IsLastToken">
            <summary>
            True if this is the last token, false otherwise
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.SimpleSyntaxHighlighter">
            <summary>
            A utility that makes it easy to perform common types of syntax highlighting based on keywords, regular expressions, etc.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.#ctor">
            <summary>
            Creates a new SimpleSyntaxHighlighter
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.AddKeyword(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor},System.StringComparison)">
            <summary>
            Registers a keyword with the highlighter.
            </summary>
            <param name="keyword">The keyword that will be highlighted when found on the command line</param>
            <param name="fg">The foreground highlight color</param>
            <param name="bg">The background highlight color</param>
            <param name="comparison">Determines how strings are compared. </param>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.AddConditionalKeyword(System.String,System.Func{PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext,System.Boolean},System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor},System.StringComparison)">
            <summary>
            Registers a keyword with the highlighter that should only be highlighted if some condition is true
            </summary>
            <param name="keyword">The keyword that will conditionally be highlighted when found on the command line</param>
            <param name="conditionEval">the conditional evaluation function</param>
            <param name="fg">The foreground highlight color</param>
            <param name="bg">The background highlight color</param>
            <param name="comparison">Determines how strings are compared. </param>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.AddRegex(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Registers a regular expression with the highlighter. Tokens that exactly match the given regex will be highlighted.
            </summary>
            <param name="regex">the regular expression pattern to search for</param>
            <param name="fg">The foreground highlight color</param>
            <param name="bg">The background highlight color</param>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.AddTokenHighlighter(PowerArgs.Cli.ITokenHighlighter)">
            <summary>
            Registers a custom token highlighter
            </summary>
            <param name="highlighter">the custom highlighter</param>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.SetQuotedStringLiteralHighlight(System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Lets you control how quoted string literals should be highlighted
            </summary>
            <param name="fg">The foreground highlight color</param>
            <param name="bg">The background highlight color</param>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.SetNumericHighlight(System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Lets you control how numeric values should be highlighted
            </summary>
            <param name="fg">The foreground highlight color</param>
            <param name="bg">The background highlight color</param>
        </member>
        <member name="M:PowerArgs.Cli.SimpleSyntaxHighlighter.TryHighlight(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            The implementation of ISyntaxHighlighter that uses the configuration you've created to perform syntax highlighting.
            </summary>
            <param name="readerContext">Context that is used internally</param>
            <returns>true if any highlighting changes were made, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Cli.IHighlighterConfigurator">
            <summary>
            An interface that defines how to dynamically configure a highlighter
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.IHighlighterConfigurator.Configure(PowerArgs.Cli.SimpleSyntaxHighlighter)">
            <summary>
            Lets implementors configure a highlighter in a dynamic way
            </summary>
            <param name="highlighter">The highlighter to configure</param>
        </member>
        <member name="T:PowerArgs.Cli.ITokenHighlighter">
            <summary>
            An interface the defines the contract for how individual tokens get syntax highlighting on the command line
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ITokenHighlighter.ShouldBeHighlighted(PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext)">
            <summary>
            Determines if this highlighter should highlight the current token with this highlighter's foreground and background
            colors.  
            </summary>
            <param name="readerContext">context from the reader</param>
            <param name="highlighterContext">context about the current token</param>
            <returns>true if this highlighter should highlight the current token, false otherwise</returns>
        </member>
        <member name="P:PowerArgs.Cli.ITokenHighlighter.HighlightForegroundColor">
            <summary>
            The foreground color of this highlighter.  If null, the console default is used.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.ITokenHighlighter.HighlightBackgroundColor">
            <summary>
            The background color of this highlighter.  If null, the console default is used.
            </summary>
        </member>
        <member name="T:PowerArgs.Cli.FixedHighlightTokenHighlighter">
            <summary>
            A highlighter that has a fixed foreground and background color.  Most highlighters derive from this base.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.FixedHighlightTokenHighlighter.HighlightForegroundColor">
            <summary>
            The foreground color of this highlighter.  If null, the console default is used.
            </summary>
        </member>
        <member name="P:PowerArgs.Cli.FixedHighlightTokenHighlighter.HighlightBackgroundColor">
            <summary>
            The background color of this highlighter.  If null, the console default is used.
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.FixedHighlightTokenHighlighter.#ctor(System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Creates a new highlighter using the given colors
            </summary>
            <param name="fg">The foreground color of this highlighter.  If null, the console default is used.</param>
            <param name="bg">The background color of this highlighter.  If null, the console default is used.</param>
        </member>
        <member name="M:PowerArgs.Cli.FixedHighlightTokenHighlighter.ShouldBeHighlighted(PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext)">
            <summary>
            Determines if this highlighter should highlight the current token with this highlighter's foreground and background
            colors.  
            </summary>
            <param name="readerContext">context from the reader</param>
            <param name="highlighterContext">context about the current token</param>
            <returns>true if this highlighter should highlight the current token, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Cli.KeywordHighlighter">
            <summary>
            A highlighter that is used to highlight a specific keyword
            </summary>
        </member>
        <member name="F:PowerArgs.Cli.KeywordHighlighter.keyword">
            <summary>
            The keyword to highlight whenever it is found
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.KeywordHighlighter.#ctor(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor},System.StringComparison)">
            <summary>
            Creates the highlighter.
            </summary>
            <param name="keyword">The keyword to highlight whenever it is found</param>
            <param name="fg">The foreground color of this highlighter.  If null, the console default is used.</param>
            <param name="bg">The background color of this highlighter.  If null, the console default is used.</param>
            <param name="comparison">determines how strings are compared.  By default the comparison is case sensitive</param>
        </member>
        <member name="M:PowerArgs.Cli.KeywordHighlighter.ShouldBeHighlighted(PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext)">
            <summary>
            Returns true if the keyword is matched, false otherwise
            </summary>
            <param name="readerContext">context from the reader</param>
            <param name="highlighterContext">context about the current token</param>
            <returns>true if the keyword matched, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Cli.ConditionalKeywordHighlighter">
            <summary>
            A keyword highlighter that highlights based on a condition
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.ConditionalKeywordHighlighter.#ctor(System.String,System.Func{PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext,System.Boolean},System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor},System.StringComparison)">
            <summary>
            Creates the highlighter.
            </summary>
            <param name="keyword">The keyword to match</param>
            <param name="conditionEval">The conditional match evaluation function</param>
            <param name="fg">The foreground color of this highlighter.  If null, the console default is used.</param>
            <param name="bg">The background color of this highlighter.  If null, the console default is used.</param>
            <param name="comparison">determines how characters are compared</param>
        </member>
        <member name="M:PowerArgs.Cli.ConditionalKeywordHighlighter.ShouldBeHighlighted(PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext)">
            <summary>
            Returns true if the token matches the keyword and the given conditional evaluation returns true
            </summary>
            <param name="readerContext">context from the reader</param>
            <param name="highlighterContext">context about the current token</param>
            <returns>true if the token matches the keyword and the given conditional evaluation returns true</returns>
        </member>
        <member name="T:PowerArgs.Cli.RegexHighlighter">
            <summary>
            A highlighter that highlights based on a regular expression match
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.RegexHighlighter.#ctor(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Creates the highlighter
            </summary>
            <param name="pattern">The regular expression pattern</param>
            <param name="fg">The foreground color of this highlighter.  If null, the console default is used.</param>
            <param name="bg">The background color of this highlighter.  If null, the console default is used.</param>
        </member>
        <member name="M:PowerArgs.Cli.RegexHighlighter.ShouldBeHighlighted(PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext)">
            <summary>
            Returns true if the regular expression is matched, false otherwise
            </summary>
            <param name="readerContext">context from the reader</param>
            <param name="highlighterContext">context about the current token</param>
            <returns>true if the regular expression is matched, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Cli.StringLiteralHighlighter">
            <summary>
            A highlighter that highlights double quoted string literals
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.StringLiteralHighlighter.#ctor(System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Creates the highlighter
            </summary>
            <param name="fg">The foreground color of this highlighter.  If null, the console default is used.</param>
            <param name="bg">The background color of this highlighter.  If null, the console default is used.</param>
        </member>
        <member name="T:PowerArgs.Cli.NumericHighlighter">
            <summary>
            A highlighter that highlights numeric values
            </summary>
        </member>
        <member name="M:PowerArgs.Cli.NumericHighlighter.#ctor(System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Creates the highlighter
            </summary>
            <param name="fg">The foreground color of this highlighter.  If null, the console default is used.</param>
            <param name="bg">The background color of this highlighter.  If null, the console default is used.</param>
        </member>
        <member name="M:PowerArgs.Cli.NumericHighlighter.ShouldBeHighlighted(PowerArgs.Cli.RichCommandLineContext,PowerArgs.Cli.HighlighterContext)">
            <summary>
            Returns true if the current token is a numeric value, false otherwise
            </summary>
            <param name="readerContext">context from the reader</param>
            <param name="highlighterContext">context about the current token</param>
            <returns>true if the current token is a numeric value, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.ContextAssistSearch">
            <summary>
            A context assist provider that lets a user search for an option.  The class is abstract.  Implementors just need to define the search implementation
            and this class will do the rest.
            </summary>
        </member>
        <member name="F:PowerArgs.ContextAssistSearch.parentReaderContext">
            <summary>
            context about the parent reader that is only populated when used by a parent reader.
            </summary>
        </member>
        <member name="P:PowerArgs.ContextAssistSearch.SelectedValue">
            <summary>
            Gets the most recent search result that was selected and committed by the user
            </summary>
        </member>
        <member name="P:PowerArgs.ContextAssistSearch.SupportsAsync">
            <summary>
            True indicates that the derived class has implemented GetResultsAsync(), which will be called by the base class.  If false then
            the base class will call GetResults() and will never call GetResultsAsync() so you can choose not to implement it.
            </summary>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.#ctor">
            <summary>
            Initializes the search assist class
            </summary>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.GetResults(System.String)">
            <summary>
            When implemented in the derived class, gets search results that match the search string.  This ONLY gets called if SupportsAsync returns false.
            </summary>
            <param name="searchString">the search string entered by the user</param>
            <returns>the search results as a list of strings</returns>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.GetResultsAsync(System.String)">
            <summary>
            When implemented in the derived class, gets search results that match the search string asynchronously.  This ONLY gets called if SupportsAsync returns true.
            </summary>
            <param name="searchString">the search string entered by the user</param>
            <returns>an async task that will return the search results as a list of strings</returns>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.CanAssist(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Always returns true.  When overrided in a derived class the derived class can provide custom logic to determine whether or not this assist provider
            can assist.
            </summary>
            <param name="parentContext">context about the parent reader that we may be assisting </param>
            <returns>Always returns true.  When overrided in a derived class the derived class can provide custom logic to determine whether or not this assist provider
            can assist.</returns>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.OnKeyboardInput(PowerArgs.Cli.RichCommandLineContext,System.ConsoleKeyInfo)">
            <summary>
            This is not implemented because this assist provider always takes over the console during the draw menu.
            </summary>
            <param name="parentReaderContext">not implemented</param>
            <param name="keyPress">not implemented</param>
            <returns>not implemented</returns>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.DrawMenu(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Writes the prompt message and takes over the console until the user makes a selection or cancels via the escape key.  This method
            never returns a NoOp result.
            </summary>
            <param name="parentContext">context about the parent reader that we are assisting </param>
            <returns>A selection or cancellation result, never a NoOp</returns>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.ClearMenu(PowerArgs.Cli.RichCommandLineContext)">
            <summary>
            Clears the menu from the console
            </summary>
            <param name="notUsed"></param>
        </member>
        <member name="M:PowerArgs.ContextAssistSearch.Search(PowerArgs.IConsoleProvider,System.Boolean)">
            <summary>
            Performs a standalone search and cleans up the menu at the end.
            </summary>
            <param name="console">Optionally choose a custom console target</param>
            <param name="allowCancel">if true, users can cancel the search by pressing the escape key.  If false, the escape key does nothing.</param>
            <returns>A valid search result or null if the search was cancelled.</returns>
        </member>
        <member name="T:PowerArgs.IConsoleProviderEx">
            <summary>
            Extension methods for IConsoleProvider
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProviderEx.TakeSnapshot(PowerArgs.IConsoleProvider)">
            <summary>
            Takes a snapshot that stores the console cursor's current position.
            </summary>
            <param name="console">the console to target</param>
            <returns>a snapshot that stores the console cursor's current position.</returns>
        </member>
        <member name="T:PowerArgs.IArgMetadataEx">
            <summary>
            Extension methods that make it easy to work with metadata collections
            </summary>
        </member>
        <member name="M:PowerArgs.IArgMetadataEx.HasMeta``1(System.Collections.Generic.IEnumerable{PowerArgs.IArgMetadata})">
            <summary>
            Returns true if the given collection of metadata contains metadata of the generic type T
            provided.
            </summary>
            <typeparam name="T">The type of metadata to search for</typeparam>
            <param name="metadata">The list of metadata to search</param>
            <returns>rue if the given collection of metadata contains metadata of the generic type T
            provided, otherwise false</returns>
        </member>
        <member name="M:PowerArgs.IArgMetadataEx.Meta``1(System.Collections.Generic.IEnumerable{PowerArgs.IArgMetadata})">
            <summary>
            Gets the first instance of metadata of the given generic type T in the collection
            or null if it was not found.
            </summary>
            <typeparam name="T">The type of metadata to search for</typeparam>
            <param name="metadata">The list of metadata to search</param>
            <returns>the first instance of an metadata of the given generic type T in the collection
            or null if it was not found</returns>
        </member>
        <member name="M:PowerArgs.IArgMetadataEx.TryGetMeta``1(System.Collections.Generic.IEnumerable{PowerArgs.IArgMetadata},``0@)">
            <summary>
            Try to get the first instance of metadata of the given generic type T in the collection.
            </summary>
            <typeparam name="T">The type of metadata to search for</typeparam>
            <param name="metadata">The list of metadata to search</param>
            <param name="ret">the our variable to set if the metadata was found</param>
            <returns>true if the metadata was found, otherwise false</returns>
        </member>
        <member name="M:PowerArgs.IArgMetadataEx.Metas``1(System.Collections.Generic.IEnumerable{PowerArgs.IArgMetadata})">
            <summary>
            Gets the subset of metadata of the given generic type T from the collection.
            </summary>
            <typeparam name="T">The type of metadata to search for</typeparam>
            <param name="metadata">The list of metadata to search</param>
            <returns>the subset of metadata of the given generic type T from the collection</returns>
        </member>
        <member name="T:PowerArgs.MatchCollectionEx">
            <summary>
            A simple helper that makes it possible to do Linq queries over a MatchCollection
            </summary>
        </member>
        <member name="M:PowerArgs.MatchCollectionEx.ToList(System.Text.RegularExpressions.MatchCollection)">
            <summary>
            Converts a MatchCollection to a List of Match objects so that you can perform linq queries over the matches.
            </summary>
            <param name="matches">The MatchCollection to convert</param>
            <returns>a list of Match objects</returns>
        </member>
        <member name="T:PowerArgs.MemberInfoEx">
            <summary>
            Provides some reflection helpers in the form of extension methods for the MemberInfo type.
            </summary>
        </member>
        <member name="M:PowerArgs.MemberInfoEx.HasAttr``1(System.Reflection.MemberInfo)">
            <summary>
            Returns true if the given member has an attribute of the given type (including inherited types).
            </summary>
            <typeparam name="T">The type of attribute to test for (will return true for attributes that inherit from this type)</typeparam>
            <param name="info">The member to test</param>
            <returns>true if a matching attribute was found, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.MemberInfoEx.Attr``1(System.Reflection.MemberInfo)">
            <summary>
            Gets the attribute of the given type or null if the member does not have this attribute defined.  The standard reflection helper GetCustomAttributes will
            give you a new instance of the attribute every time you call it.  This helper caches it's results so if you ask for the same attibute twice you will actually
            get back the same attribute.  Note that the cache key is based off of the type T that you provide.  So asking for Attr() where T : BaseType> and then asking for Attr() where T : ConcreteType 
            will result in two different objects being returned.  If you ask for Attr() where T : BaseType and then Attr() where T :BaseType the caching will work and you'll get the same object back
            the second time.
            </summary>
            <typeparam name="T">The type of attribute to search for</typeparam>
            <param name="info">The member to inspect</param>
            <returns>The desired attribute or null if it is not present</returns>
        </member>
        <member name="M:PowerArgs.MemberInfoEx.Attrs``1(System.Reflection.MemberInfo)">
            <summary>
            Gets the attributes of the given type.  The standard reflection helper GetCustomAttributes will give you new instances of the attributes every time you call it.  
            This helper caches it's results so if you ask for the same attibutes twice you will actually get back the same attributes.  Note that the cache key is based off 
            of the type T that you provide.  So asking for Attrs() where T : BaseType and then asking for Attrs() where T : ConcreteType
            will result in two different sets of objects being returned.  If you ask for Attrs() where T : BaseType and then Attrs() where T : BaseType the caching will work and you'll get the
            same results back the second time.
            </summary>
            <typeparam name="T">The type of attribute to search for</typeparam>
            <param name="info">The member to inspect</param>
            <returns>The list of attributes that you asked for</returns>
        </member>
        <member name="T:PowerArgs.StringEx">
            <summary>
            string extension methods
            </summary>
        </member>
        <member name="M:PowerArgs.StringEx.ToConsoleString(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Converts a string to a ConsoleString
            </summary>
            <param name="s">the string to convert</param>
            <param name="fg">the foreground color to apply to the result</param>
            <param name="bg">the background color to apply to the result</param>
            <returns>a console string</returns>
        </member>
        <member name="T:PowerArgs.ParemeterInfoEx">
            <summary>
            Some useful helper extensions for the ParameterInfo type
            </summary>
        </member>
        <member name="M:PowerArgs.ParemeterInfoEx.HasAttr``1(System.Reflection.ParameterInfo)">
            <summary>
            Returns true if the given parameter has an attribute of the given type (including inherited types).
            </summary>
            <typeparam name="T">The type of attribute to test for (will return true for attributes that inherit from this type)</typeparam>
            <param name="info">The parameter to test</param>
            <returns>true if a matching attribute was found, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ParemeterInfoEx.Attr``1(System.Reflection.ParameterInfo)">
            <summary>
            Gets the attribute of the given type or null if the parameter does not have this attribute defined.  The standard reflection helper GetCustomAttributes will
            give you a new instance of the attribute every time you call it.  This helper caches it's results so if you ask for the same attibute twice you will actually
            get back the same attribute.  Note that the cache key is based off of the type T that you provide.  So asking for Attr() where T : BaseType> and then asking for Attr() where T : ConcreteType 
            will result in two different objects being returned.  If you ask for Attr() where T : BaseType and then Attr() where T :BaseType the caching will work and you'll get the same object back
            the second time.
            </summary>
            <typeparam name="T">The type of attribute to search for</typeparam>
            <param name="info">The parameter to inspect</param>
            <returns>The desired attribute or null if it is not present</returns>
        </member>
        <member name="M:PowerArgs.ParemeterInfoEx.Attrs``1(System.Reflection.ParameterInfo)">
            <summary>
            Gets the attributes of the given type.  The standard reflection helper GetCustomAttributes will give you new instances of the attributes every time you call it.  
            This helper caches it's results so if you ask for the same attibutes twice you will actually get back the same attributes.  Note that the cache key is based off 
            of the type T that you provide.  So asking for Attrs() where T : BaseType and then asking for Attrs() where T : ConcreteType
            will result in two different sets of objects being returned.  If you ask for Attrs() where T : BaseType and then Attrs() where T : BaseType the caching will work and you'll get the
            same results back the second time.
            </summary>
            <typeparam name="T">The type of attribute to search for</typeparam>
            <param name="info">The parameter to inspect</param>
            <returns>The list of attributes that you asked for</returns>
        </member>
        <member name="T:PowerArgs.ConsoleOutInterceptor">
            <summary>
            A singleton text writer that can be used to intercept console output.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleOutInterceptor.IsInitialized">
            <summary>
            returns true if the instance is initialized and is intercepting
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleOutInterceptor.Instance">
            <summary>
            Gets the interceptor, initializing it if needed.  
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleOutInterceptor.Attach">
            <summary>
            Attaches the interceptor to the Console so that it starts intercepting output
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleOutInterceptor.Detatch">
            <summary>
            Detaches the interceptor.  Console output will be written as normal.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleOutInterceptor.Write(System.Char[],System.Int32,System.Int32)">
            <summary>
            Intercepts the Write event
            </summary>
            <param name="buffer">the string buffer</param>
            <param name="index">the start index</param>
            <param name="count">number of chars to write</param>
        </member>
        <member name="M:PowerArgs.ConsoleOutInterceptor.Write(System.Char)">
            <summary>
            Intercepts the Write event
            </summary>
            <param name="value">the char to write</param>
        </member>
        <member name="M:PowerArgs.ConsoleOutInterceptor.Write(System.String)">
            <summary>
            Intercepts the Write event
            </summary>
            <param name="value">the string to write</param>
        </member>
        <member name="M:PowerArgs.ConsoleOutInterceptor.Write(PowerArgs.ConsoleString)">
            <summary>
            Pretends to intercept a ConsoleString
            </summary>
            <param name="value">the string to intercept</param>
        </member>
        <member name="M:PowerArgs.ConsoleOutInterceptor.ReadAndClear">
            <summary>
            Reads the queued up intercepted characters and then clears the queue as an atomic operation.
            This method is thread safe.
            </summary>
            <returns>The queued up intercepted characters</returns>
        </member>
        <member name="P:PowerArgs.ConsoleOutInterceptor.Encoding">
            <summary>
            Returns System.Text.Encoding.Default
            </summary>
        </member>
        <member name="T:PowerArgs.ExpireableAsyncRequestManager">
            <summary>
            A utility that can be used to implement the following request pattern.  A user starts typing, triggering an async search.  
            While the async search is running, the user continues typing, triggering more searches.  Your goal is to ignore searches that
            are in flight, but are no longer the latest search.  This helper provides a programming model around orchestrating that behavior.
            </summary>
        </member>
        <member name="M:PowerArgs.ExpireableAsyncRequestManager.#ctor">
            <summary>
            Creates a new instance of the helper context
            </summary>
        </member>
        <member name="M:PowerArgs.ExpireableAsyncRequestManager.BeginRequest">
            <summary>
            You should call this from your foreground thread just before starting your async search request.  It will return a unique Id
            that you should make available to your code that runs when your async request completes.
            </summary>
            <returns>a unique Id
            that you should make available to your code that runs when your async request completes</returns>
        </member>
        <member name="M:PowerArgs.ExpireableAsyncRequestManager.EndRequest(System.Action,System.Guid)">
            <summary>
            When your async call is complete, and you have your results, call this method, passing in the action that should
            only be run if two conditions are both true.  1 - The given request Id represents the latest request.  2 - Nobody has
            called ExpireAll() on the context.
            </summary>
            <param name="endAction">the action to invoke only if the context is not expired and the given request id represents the most recent request</param>
            <param name="requestId">The request Id that you got from BeginRequest </param>
        </member>
        <member name="M:PowerArgs.ExpireableAsyncRequestManager.ExpireAll">
            <summary>
            Calling this method will disable end actions for the latest request as well as any future requests.  This is useful if your application
            have moved on to a different context and you want to ignore any pending requests.
            </summary>
        </member>
        <member name="T:PowerArgs.ConsoleInDriver">
            <summary>
             A utility that can be used to drive input to Console.In programatically.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleInDriver.IsAttached">
            <summary>
            Gets a value indicating whether or not the driver is currently attached to Console.In
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleInDriver.Instance">
            <summary>
            Gets the singleton instance of the driver
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.Attach">
            <summary>
            Attaches the drives to Console.In
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.Detach">
            <summary>
            Detaches the driver from Console.In and reopens and reconnects the standard input stream.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.Drive(System.String)">
            <summary>
            Drives a string of text into Console.In
            </summary>
            <param name="s">the string to drive</param>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.DriveLine(System.String)">
            <summary>
            Drives a string of text into Console.In, followed by a newline character
            </summary>
            <param name="s">the string to drive</param>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.Peek">
            <summary>
            Not implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.Read">
            <summary>
            Reads the next char from the driver as an int.
            </summary>
            <returns>the next char from the driver as an int.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Not implemented
            </summary>
            <param name="buffer">Not implemented</param>
            <param name="index">Not implemented</param>
            <param name="count">Not implemented</param>
            <returns>Not implemented</returns>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.ReadBlock(System.Char[],System.Int32,System.Int32)">
            <summary>
            Not implemented
            </summary>
            <param name="buffer">Not implemented</param>
            <param name="index">Not implemented</param>
            <param name="count">Not implemented</param>
            <returns>Not implemented</returns>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.ReadLine">
            <summary>
            reads a line of input from the driver
            </summary>
            <returns>a line of input from the driver</returns>
        </member>
        <member name="M:PowerArgs.ConsoleInDriver.ReadToEnd">
            <summary>
            Not implemented
            </summary>
            <returns>Not implemented</returns>
        </member>
        <member name="T:PowerArgs.PowerLogger">
            <summary>
            A class that PowerArgs uses internally for diagnostics
            </summary>
        </member>
        <member name="P:PowerArgs.PowerLogger.LogFile">
            <summary>
            The log file to write to or "Console" if logs should be written to the console
            </summary>
        </member>
        <member name="M:PowerArgs.PowerLogger.LogLine(System.String,System.Int32)">
            <summary>
            Logs a line of text
            </summary>
            <param name="s">the text to log</param>
            <param name="retryCount">don't use</param>
        </member>
        <member name="T:PowerArgs.AliasCollection">
            <summary>
            This class tracks the command line aliases for a CommandLineArgument and a CommandLineAction.
            It combines the aliases that have been retrieved from the ArgShortcut attibute and any additional
            aliases that may have been added to the model manually into a single collection.  It also makes sure that those two sources
            of aliases don't conflict.
            
            </summary>
        </member>
        <member name="M:PowerArgs.AliasCollection.IndexOf(System.String)">
            <summary>
            Gets the index of the given alias in the collection.
            </summary>
            <param name="item">the alias to look for</param>
            <returns>The index of item if found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:PowerArgs.AliasCollection.Insert(System.Int32,System.String)">
            <summary>
            Not supported
            </summary>
            <param name="index">Not supported</param>
            <param name="item">Not supported</param>
        </member>
        <member name="M:PowerArgs.AliasCollection.RemoveAt(System.Int32)">
            <summary>
            Not supported
            </summary>
            <param name="index">Not supported</param>
        </member>
        <member name="P:PowerArgs.AliasCollection.Item(System.Int32)">
            <summary>
            The setter is not supported.  The getter returns the item at the specified index.
            </summary>
            <param name="index"></param>
            <returns>the item at the specified index</returns>
        </member>
        <member name="M:PowerArgs.AliasCollection.AddRange(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Adds the given aliases to the collection. 
            </summary>
            <param name="items">The alias to add</param>
        </member>
        <member name="M:PowerArgs.AliasCollection.Add(System.String)">
            <summary>
            Adds the given alias to the collection.  An InvalidArgDefinitionException is thrown if you try to add
            the same alias twice (case sensitivity is determined by the CommandLineArgument or CommandLineAction).
            </summary>
            <param name="item">The alias to add</param>
        </member>
        <member name="M:PowerArgs.AliasCollection.Clear">
            <summary>
            Clear is not supported, use ClearOverrides() to clear items that have manually been added
            </summary>
        </member>
        <member name="M:PowerArgs.AliasCollection.ClearOverrides">
            <summary>
            Clears the aliases that have been manually addd to this collection via Add() or AddRange().
            Aliases that are inferred from the Metadata will still be present in the collection. 
            </summary>
        </member>
        <member name="M:PowerArgs.AliasCollection.Contains(System.String)">
            <summary>
            Tests to see if this Alias collection contains the given item.  Case sensitivity is enforced
            based on the CommandLineArgument or CommandLineAction.
            </summary>
            <param name="item">The item to test for containment</param>
            <returns>True if the collection contains the item, otherwise false</returns>
        </member>
        <member name="M:PowerArgs.AliasCollection.CopyTo(System.String[],System.Int32)">
            <summary>
            Copies this collection to an array, starting at the given index
            </summary>
            <param name="array">the destination array</param>
            <param name="arrayIndex">the starting index of where to place the elements into the destination</param>
        </member>
        <member name="P:PowerArgs.AliasCollection.Count">
            <summary>
            Gets the count of aliases
            </summary>
        </member>
        <member name="P:PowerArgs.AliasCollection.IsReadOnly">
            <summary>
            Not read only ever
            </summary>
        </member>
        <member name="M:PowerArgs.AliasCollection.Remove(System.String)">
            <summary>
            Removes the given alias from the collection if it was added via Add() or AddRange().  If
            it was added by injecting metadata into a CommandLineArgument or a CommandLineAction then
            an InvalidOperationException will be thrown.  The correct way to remove metadata injected
            aliases is to remove it from the metadata directly.
            </summary>
            <param name="item">the item to remove</param>
            <returns>true if the alias was removed, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.AliasCollection.GetEnumerator">
            <summary>
            Gets an enumerator capable of enumerating all aliases
            </summary>
            <returns>an enumerator capable of enumerating all aliases</returns>
        </member>
        <member name="M:PowerArgs.AliasCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator capable of enumerating all aliases
            </summary>
            <returns>an enumerator capable of enumerating all aliases</returns>
        </member>
        <member name="T:PowerArgs.ArgAction`1">
            <summary>
            This is the more complex version of the public result that is produced by the parser.
            </summary>
            <typeparam name="T">Represents the custom argument scaffold type that was passed to the parser.</typeparam>
        </member>
        <member name="P:PowerArgs.ArgAction`1.Args">
            <summary>
            The instance of your custom scaffold type that the parser generated and parsed.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgAction">
            <summary>
            This is the weakly typed, more complex version of the public result that is produced by the parser.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.Definition">
            <summary>
            The definition or model that was used to parse the arguments
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.Value">
            <summary>
            The instance of your custom scaffold type that the parser generated and parsed.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.ActionArgs">
            <summary>
            If you used the action framework then this will represent the instance of the action specific arguments
            that were parsed.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.ActionArgsProperty">
            <summary>
            If you used the action framework then this will map to the property that the user specified as the first
            parameter on the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.ActionParameters">
            <summary>
            This is set if you defined your action via a method with simple parameters
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.HandledException">
            <summary>
            If an exception was handled by the parser then this property will be populated and others will not be.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgAction.Cancelled">
            <summary>
            If processing was cancelled then this property will be set to true.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgAction.Invoke">
            <summary>
            This will find the implementation method for your action and invoke it, passing the action specific
            arguments as a parameter.
            </summary>
        </member>
        <member name="T:PowerArgs.ConsoleProvider">
            <summary>
            The console provider that is used across all of Powerargs
            </summary>
        </member>
        <member name="F:PowerArgs.ConsoleProvider.Current">
            <summary>
            Gets or sets the console implementation that is targeted by PowerArgs.  By default, PowerArgs uses the standard system console.  In theory,
            you can implement a custom version of IConsoleProvider and plug it in here.  Everything should work, but it has not been attempted.  Proceed with caution.
            </summary>
        </member>
        <member name="T:PowerArgs.BooleanExpressionParser">
            <summary>
            A simple boolean expression parser that supports and '&amp;', or '|', and grouping via parentheses.
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanExpressionParser.Parse(System.String)">
            <summary>
            Parses the given boolean expression which can be made up of variables and boolean operators (and '&amp;' and or '|') grouped by parentheses.
            </summary>
            <param name="expressionText">The expression to parse</param>
            <returns>The parsed expression</returns>
        </member>
        <member name="M:PowerArgs.BooleanExpressionParser.Revive(System.String,System.String)">
            <summary>
            A reviver that makes boolean expressions specificable on the command line
            </summary>
            <param name="key">not used</param>
            <param name="val">the expression text</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.BooleanOperator">
            <summary>
            Represents the set of supported boolean operators
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanOperator.And">
            <summary>
            Represents an 'and' boolean operation
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanOperator.Or">
            <summary>
            Represents an 'or' boolean operation
            </summary>
        </member>
        <member name="T:PowerArgs.BooleanExpressionTokenType">
            <summary>
            An enum representing a type of boolean expression token
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.Variable">
            <summary>
            Represents a boolean variable
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.GroupOpen">
            <summary>
            Represents the beginning of a logically grouped boolean expression
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.GroupClose">
            <summary>
            Represents the end of a logically grouped boolean expression
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.And">
            <summary>
            Represents an 'and' clause in a boolean expression
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.Or">
            <summary>
            Represents an 'or' clause in a boolean expression
            </summary>
        </member>
        <member name="F:PowerArgs.BooleanExpressionTokenType.Not">
            <summary>
            Indicates that an expression should be negated
            </summary>
        </member>
        <member name="T:PowerArgs.BooleanExpressionToken">
            <summary>
            A class that represents a boolean expression token
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanExpressionToken.Type">
            <summary>
            The type of token
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanExpressionToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a boolean expression token
            </summary>
            <param name="tokenText">the token text</param>
            <param name="startIndex">the start index of the token value</param>
            <param name="line">the line number of the token value</param>
            <param name="col">the column number of the token value</param>
        </member>
        <member name="T:PowerArgs.IBooleanVariableResolver">
            <summary>
            An interface that describes how to resolve boolean variables that can be either true or false
            </summary>
        </member>
        <member name="M:PowerArgs.IBooleanVariableResolver.ResolveBoolean(System.String)">
            <summary>
            Implementations should provide a value of true or false for each variable specified.  Implementations can
            choose how to handle unknown variables either by throwing or returning a default value.
            </summary>
            <param name="variableName"></param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.FuncBooleanVariableResolver">
            <summary>
            A class that can resolve a boolean variable based on a function.
            </summary>
        </member>
        <member name="P:PowerArgs.FuncBooleanVariableResolver.ResolverImpl">
            <summary>
            The function that knows how to resolve boolean variables
            </summary>
        </member>
        <member name="M:PowerArgs.FuncBooleanVariableResolver.#ctor(System.Func{System.String,System.Boolean})">
            <summary>
            Creates a new variable resolver given an implementation as a function.
            </summary>
            <param name="resolverImpl"></param>
        </member>
        <member name="M:PowerArgs.FuncBooleanVariableResolver.ResolveBoolean(System.String)">
            <summary>
            Resolves the given variable using the wrapped function
            </summary>
            <param name="variableName"></param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.IBooleanExpression">
            <summary>
            An interface representing a node in a boolean expression that can either be true or false.
            </summary>
        </member>
        <member name="M:PowerArgs.IBooleanExpression.Evaluate(PowerArgs.IBooleanVariableResolver)">
            <summary>
            Evaluates the state of the node (true or false) given a variable resolver.
            </summary>
            <param name="resolver">the object to use to resolve boolean variables</param>
            <returns>the result of the expression, true or false</returns>
        </member>
        <member name="M:PowerArgs.IBooleanExpression.Evaluate(System.Collections.Generic.Dictionary{System.String,System.Boolean})">
            <summary>
            Evaluates the state of the node (true or false) given a set of variable values.
            </summary>
            <param name="variableValues">The current state of variables</param>
            <returns>the result of the expression, true or false</returns>
        </member>
        <member name="P:PowerArgs.IBooleanExpression.Not">
            <summary>
            Gets or sets a flag indicating that the expression should be negated
            </summary>
        </member>
        <member name="T:PowerArgs.BooleanVariable">
            <summary>
            A node in a boolean expression that represents a variable that can either be true or false.
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanVariable.Not">
            <summary>
            Gets or sets a flag indicating that the variable's value should be negated
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanVariable.VariableName">
            <summary>
            The name of the variable referenced by this node
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanVariable.Evaluate(PowerArgs.IBooleanVariableResolver)">
            <summary>
            Uses the given resolver to resolve the target boolean variable
            </summary>
            <param name="resolver">The object used to resolve boolean variables</param>
            <returns>the result of the resolver</returns>
        </member>
        <member name="M:PowerArgs.BooleanVariable.Evaluate(System.Collections.Generic.Dictionary{System.String,System.Boolean})">
            <summary>
            Evaluates the expression given a set of variable values
            </summary>
            <param name="variableValues">The value of variables that appear in the expression</param>
            <returns>True if the expression was true, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.BooleanVariable.ToString">
            <summary>
            Gets a string representation of the variable
            </summary>
            <returns>a string representation of the variable</returns>
        </member>
        <member name="T:PowerArgs.BooleanExpressionGroup">
            <summary>
            A class that represents a boolean expression that supports and, or, and grouping.
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanExpressionGroup.Not">
            <summary>
            Gets or sets a flag indicating that the expression should be negated
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanExpressionGroup.Operands">
            <summary>
            The operands (variables or grouped child expressions) that make up this expression.
            </summary>
        </member>
        <member name="P:PowerArgs.BooleanExpressionGroup.Operators">
            <summary>
            The operators to apply between each operand
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanExpressionGroup.#ctor">
            <summary>
            Creates a new empty boolean expression
            </summary>
        </member>
        <member name="M:PowerArgs.BooleanExpressionGroup.Evaluate(System.Collections.Generic.Dictionary{System.String,System.Boolean})">
            <summary>
            Evaluates the expression given a set of variable values
            </summary>
            <param name="variableValues">The value of variables that appear in the expression</param>
            <returns>True if the expression was true, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.BooleanExpressionGroup.Evaluate(PowerArgs.IBooleanVariableResolver)">
            <summary>
            Evaluates the expression given a variable resolver.
            </summary>
            <param name="resolver">An object used to resolve variables that appear in the expression</param>
            <returns>True if the expression was true, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.BooleanExpressionGroup.ToString">
            <summary>
            Gets a string representation of the variable
            </summary>
            <returns>a string representation of the variable</returns>
        </member>
        <member name="T:PowerArgs.ConsoleSnapshot">
            <summary>
            An object that tracks and restores the cursor on a console
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleSnapshot.Left">
            <summary>
            Gets or sets the left position of the snapshot
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleSnapshot.Top">
            <summary>
            Gets or sets the top position of the snapshot
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleSnapshot.Console">
            <summary>
            Gets a reference to the console this snapshot was taken from
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleSnapshot.#ctor(System.Int32,System.Int32,PowerArgs.IConsoleProvider)">
            <summary>
            Creates a snapshot with explicit cursor position values
            </summary>
            <param name="left">the left position of the snapshot</param>
            <param name="top">the top position of the snapshot</param>
            <param name="console">the target console</param>
        </member>
        <member name="M:PowerArgs.ConsoleSnapshot.#ctor(PowerArgs.IConsoleProvider)">
            <summary>
            Creates a snapshot from the given console's current position
            </summary>
            <param name="console">the target console</param>
        </member>
        <member name="M:PowerArgs.ConsoleSnapshot.CreateOffsetSnapshot(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new snapshot that is offset from the current 
            snapshot
            </summary>
            <param name="xOffset">the delta from this snapshot's Left value</param>
            <param name="yOffset">the delta from this snapshot's Top value</param>
            <returns> a new snapshot that is offset from the current snapshot</returns>
        </member>
        <member name="M:PowerArgs.ConsoleSnapshot.Restore">
            <summary>
            Restores the target console to this snapshot's cursor position
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleSnapshot.Finalize">
            <summary>
            restores the snapshot
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleSnapshot.Dispose">
            <summary>
            Restores the target console to this snapshot's cursor position
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleSnapshot.Dispose(System.Boolean)">
            <summary>
            Restores the target console to this snapshot's cursor position
            </summary>
            <param name="disposing">used for correct dispose pattern impl</param>
        </member>
        <member name="T:PowerArgs.ConsoleCharacter">
            <summary>
            A wrapper for char that encapsulates foreground and background colors.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleCharacter.Value">
            <summary>
            The value of the character
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleCharacter.ForegroundColor">
            <summary>
            The console foreground color to use when printing this character.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleCharacter.BackgroundColor">
            <summary>
            The console background color to use when printing this character.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.#ctor(System.Char,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Create a new ConsoleCharacter given a char value and optionally set the foreground or background coor.
            </summary>
            <param name="value">The character value</param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Write">
            <summary>
            Write this formatted character to the console
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.ToString">
            <summary>
            Gets the string representation of the character
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.Equals(System.Object)">
            <summary>
            ConsoleCharacters can be compared to other ConsoleCharacter instances or char values.
            </summary>
            <param name="obj">The ConsoleCharacter or char to compare to.</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Equality(PowerArgs.ConsoleCharacter,PowerArgs.ConsoleCharacter)">
            <summary>
            Operator overload for Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Inequality(PowerArgs.ConsoleCharacter,PowerArgs.ConsoleCharacter)">
            <summary>
            Operator overload for !Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Equality(PowerArgs.ConsoleCharacter,System.Char)">
            <summary>
            Operator overload for Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.op_Inequality(PowerArgs.ConsoleCharacter,System.Char)">
            <summary>
            Operator overload for !Equals
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.GetHashCode">
            <summary>
            Override of GetHashcode that returns the internal char's hashcode.
            </summary>
            <returns>the internal char's hashcode.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleCharacter.ToConsoleString">
            <summary>
            Formats this object as a ConsoleString
            </summary>
            <returns>a ConsoleString</returns>
        </member>
        <member name="T:PowerArgs.ConsoleString">
            <summary>
            A wrapper for string that encapsulates foreground and background colors.  ConsoleStrings are immutable.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleString.ConsoleProvider">
            <summary>
            The console provider to use when writing output
            </summary>
        </member>
        <member name="F:PowerArgs.ConsoleString.Empty">
            <summary>
            Represents an empty string.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleString.StringValue">
            <summary>
            Gets the string value of this ConsoleString.  Useful when using the debugger.
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleString.Length">
            <summary>
            The length of the string.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleString.#ctor">
            <summary>
            Create a new empty ConsoleString
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleString.#ctor(System.Collections.Generic.IEnumerable{PowerArgs.ConsoleCharacter})">
            <summary>
            Creates a new ConsoleString from a collection of ConsoleCharacter objects
            </summary>
            <param name="chars">The value to use to seed this string</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.#ctor(System.Collections.Generic.List{PowerArgs.ConsoleCharacter})">
            <summary>
            Creates a new ConsoleString from a list of ConsoleCharacter objects
            </summary>
            <param name="chars">The value to use to seed this string</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.#ctor(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Create a ConsoleString given an initial text value and optional color info.
            </summary>
            <param name="value"></param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToConsoleStrings(System.Collections.Generic.IEnumerable{System.String},System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Converts a collection of plain strings into ConsoleStrings
            </summary>
            <param name="plainStrings">the input strings</param>
            <param name="foregroundColor">the foreground color of all returned ConsoleStrings</param>
            <param name="backgroundColor">the background color of all returned ConsoleStrings</param>
            <returns>a collection of ConsoleStrnigs</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.AppendUsingCurrentFormat(System.String)">
            <summary>
            Returns a new string that Appends the given value to this one using the formatting of the last character or the default formatting if this ConsoleString is empty.
            </summary>
            <param name="value">The string to append.</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.Replace(System.String,System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor},System.StringComparison)">
            <summary>
            Replaces all occurrances of the given string with the replacement value using the specified formatting.
            </summary>
            <param name="toFind">The substring to find</param>
            <param name="toReplace">The replacement value</param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
            <param name="comparison">Specifies how characters are compared</param>
            <returns>A new ConsoleString with the replacements.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Highlight(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor},System.StringComparison)">
            <summary>
            Highights all occurrances of the given string with the desired foreground and background color.
            </summary>
            <param name="toFind">The substring to find</param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
            <param name="comparison">Specifies how characters are compared</param>
            <returns>A new ConsoleString with the highlights.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToDifferentBackground(System.Nullable{System.ConsoleColor})">
            <summary>
            Creates a new ConsoleString with the sam characters as this one, but with a 
            new background color
            </summary>
            <param name="bg">the new background color</param>
            <returns>A  new string with a different background color</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.HighlightSubstring(System.Int32,System.Int32,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Returns a new ConsoleString that is a copy of this ConsoleString, but applies the given style to the range of characters specified.
            </summary>
            <param name="start">the start index to apply the highlight</param>
            <param name="length">the number of characters to apply the highlight</param>
            <param name="foregroundColor">the foreground color to apply to the highlighted characters or null to use the default foreground color</param>
            <param name="backgroundColor">the background color to apply to the highlighted characters or null to use the default background color</param>
            <returns>a new ConsoleString that is a copy of this ConsoleString, but applies the given style to the range of characters specified.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ReplaceRegex(System.String,System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Replaces all matches of the given regular expression with the replacement value using the specified formatting.
            </summary>
            <param name="regex">The regular expression to find.</param>
            <param name="toReplace">The replacement value</param>
            <param name="foregroundColor">The foreground color (defaults to the console's foreground color at initialization time).</param>
            <param name="backgroundColor">The background color (defaults to the console's background color at initialization time).</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.IndexOf(System.String,System.StringComparison)">
            <summary>
            Finds the index of a given substring in this ConsoleString.
            </summary>
            <param name="toFind">The substring to search for.</param>
            <param name="comparison">Specifies how characters are compared</param>
            <returns>The first index of the given substring or -1 if the substring was not found.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.StartsWith(System.String,System.StringComparison)">
            <summary>
            Determines if this ConsoleString starts with the given string
            </summary>
            <param name="substr">the substring to look for</param>
            <param name="comparison">Specifies how characters are compared</param>
            <returns>true if this ConsoleString starts with the given substring, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.EndsWith(System.String,System.StringComparison)">
            <summary>
            Determines if this ConsoleString ends with the given string
            </summary>
            <param name="substr">the substring to look for</param>
            <param name="comparison">Specifies how characters are compared</param>
            <returns>true if this ConsoleString ends with the given substring, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Contains(System.String,System.StringComparison)">
            <summary>
            Determines if this ConsoleString contains the given substring.
            </summary>
            <param name="substr">The substring to search for.</param>
            <param name="comparison">Specifies how characters are compared</param>
            <returns>True if found, false otherwise.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Substring(System.Int32)">
            <summary>
            Get a substring of this ConsoleString starting at the given index.
            </summary>
            <param name="start">the start index.</param>
            <returns>A new ConsoleString representing the substring requested.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Substring(System.Int32,System.Int32)">
            <summary>
            Get a substring of this ConsoleString starting at the given index and with the given length.
            </summary>
            <param name="start">the start index.</param>
            <param name="length">the number of characters to return</param>
            <returns>A new ConsoleString representing the substring requested.</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Write(System.Object,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Writes the string representation of the given object to the console using the specified colors.
            </summary>
            <param name="o">The object to write</param>
            <param name="fg">The foreground color to use</param>
            <param name="bg">The background color to use</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.WriteLine(System.Object,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Writes the string representation of the given object to the console using the specified colors and appends a newline.
            </summary>
            <param name="o">The object to write</param>
            <param name="fg">The foreground color to use</param>
            <param name="bg">The background color to use</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.Write(PowerArgs.ConsoleString)">
            <summary>
            Writes the given ConsoleString to the console
            </summary>
            <param name="str">the string to write</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.WriteLine(PowerArgs.ConsoleString)">
            <summary>
            Writes the given ConsoleString to the console and appends a newline
            </summary>
            <param name="str">the string to write</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.Write(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Writes the string to the console using the specified colors.
            </summary>
            <param name="str">The object to write</param>
            <param name="fg">The foreground color to use</param>
            <param name="bg">The background color to use</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.WriteLine(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Writes the string to the console using the specified colors and appends a newline.
            </summary>
            <param name="str">The object to write</param>
            <param name="fg">The foreground color to use</param>
            <param name="bg">The background color to use</param>
        </member>
        <member name="M:PowerArgs.ConsoleString.Write">
            <summary>
            Write this ConsoleString to the console using the desired style.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleString.WriteLine">
            <summary>
            Write this ConsoleString to the console using the desired style.  A newline is appended.
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToString">
            <summary>
            Get the string representation of this ConsoleString.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.Equals(System.Object)">
            <summary>
            Compare this ConsoleString to another ConsoleString or a plain string.
            </summary>
            <param name="obj">The ConsoleString or plain string to compare to.</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.CompareTo(System.String)">
            <summary>
            Compare this ConsoleString to another ConsoleString.
            </summary>
            <param name="other">The ConsoleString to compare to.</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.GetHashCode">
            <summary>
            Gets the hashcode of the underlying string
            </summary>
            <returns>the hashcode of the underlying string</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Addition(PowerArgs.ConsoleString,PowerArgs.ConsoleString)">
            <summary>
            Operator overload that concatenates 2 ConsoleString instances and returns a new one.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>A new, concatenated ConsoleString</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Addition(PowerArgs.ConsoleString,System.String)">
            <summary>
            Operator overload that concatenates a ConsoleString with a string and returns a new one.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>A new, concatenated ConsoleString</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Equality(PowerArgs.ConsoleString,PowerArgs.ConsoleString)">
            <summary>
            Compares 2 ConsoleStrings for equality.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>True if they are the same, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.op_Inequality(PowerArgs.ConsoleString,PowerArgs.ConsoleString)">
            <summary>
            Compares 2 ConsoleStrings for inequality.
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <returns>False if they are the same, true otherwise</returns>
        </member>
        <member name="P:PowerArgs.ConsoleString.Item(System.Int32)">
            <summary>
            Gets the character at the specified index
            </summary>
            <param name="index">the index of the character to find</param>
            <returns>the character at the specified index</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.ToConsoleString">
            <summary>
            Formats this object as a ConsoleString
            </summary>
            <returns>a ConsoleString</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.GetEnumerator">
            <summary>
            Gets an enumerator for this string
            </summary>
            <returns>an enumerator for this string</returns>
        </member>
        <member name="M:PowerArgs.ConsoleString.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for this string
            </summary>
            <returns>an enumerator for this string</returns>
        </member>
        <member name="T:PowerArgs.ConsoleStringX">
            <summary>
            Extensions that make it easy to work with ConsoleStrings
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleStringX.ToConsoleString(System.Collections.Generic.IEnumerable{PowerArgs.ConsoleCharacter})">
            <summary>
            Converts the given enumeration of console characters to a console string
            </summary>
            <param name="buffer">the characters to convert to a console string</param>
            <returns>the new console string</returns>
        </member>
        <member name="M:PowerArgs.ConsoleStringX.ToNormalString(System.Collections.Generic.IEnumerable{PowerArgs.ConsoleCharacter})">
            <summary>
            Converts the given enumeration of console characters to a normal string
            </summary>
            <param name="buffer">the characters to convert to a normal string</param>
            <returns>the new string</returns>
        </member>
        <member name="T:PowerArgs.ConsoleTableBuilder">
            <summary>
            A class that makes it easy to build strings that look and feel like tables when displayed in a console
            </summary>
        </member>
        <member name="M:PowerArgs.ConsoleTableBuilder.FormatAsTable(System.Collections.Generic.List{PowerArgs.ConsoleString},System.Collections.Generic.List{System.Collections.Generic.List{PowerArgs.ConsoleString}},System.String,System.Collections.Generic.List{PowerArgs.ColumnOverflowBehavior},System.Int32)">
            <summary>
            Formats the given data as a string that looks and feels like a table when displayed in a console
            </summary>
            <param name="columnHeaders">The headers for the table</param>
            <param name="rows">The cell data for the table</param>
            <param name="rowPrefix">A prefix, usually an indentation, to append before each row, including the headers</param>
            <param name="columnOverflowBehaviors">Optionally provide hints as to how overflow should be handled.  By default, the longest value in a column determines the column width.  You can choose to truncate or to do a smart wrap.</param>
            <param name="gutter">How many empty spaces to place between columns</param>
            <returns>The table, as a console string</returns>
        </member>
        <member name="M:PowerArgs.ConsoleTableBuilder.FormatAsTable(System.Collections.IEnumerable,System.String)">
            <summary>
            Formats the given collection as a string that looks and feels like a table when displayed in a console.
            </summary>
            <param name="objects">The objects to format</param>
            <param name="format">A space delimited set of properties to use as column headers.  
            You can change the display string for a particular property by using the format 'PropertyName>DisplayName' where PropertyName is a property name and DisplayName is the text to display.  If you omit this parameter then the first object in the collection will be inspected and it's public properties will be used as columns.</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.ColumnOverflowBehavior">
            <summary>
            An abstract class that lets you describe how to handle variable column widths when formatting a console table.  You should
            not derive from this class.  All supported child classes are defined in this assembly.
            </summary>
        </member>
        <member name="T:PowerArgs.GrowUnboundedOverflowBehavior">
            <summary>
            A class that indicates that the target column should be sized based on the longest value in the column, with no upper bound
            </summary>
        </member>
        <member name="T:PowerArgs.TruncateOverflowBehavior">
            <summary>
            A class that indicates that the target column should not exceed a max size, and should be truncated if it does
            </summary>
        </member>
        <member name="P:PowerArgs.TruncateOverflowBehavior.TruncationText">
            <summary>
            The truncation indicator, by default '...'
            </summary>
        </member>
        <member name="P:PowerArgs.TruncateOverflowBehavior.ColumnWidth">
            <summary>
            The width of the column.  Note that your text may be truncated even if it is smaller than this size because the
            truncation indicator, by default, takes 3 characters '...'
            </summary>
        </member>
        <member name="P:PowerArgs.TruncateOverflowBehavior.MaxWidthBeforeShowingTruncationText">
            <summary>
            The max length a value in this column can be without being truncated
            </summary>
        </member>
        <member name="M:PowerArgs.TruncateOverflowBehavior.#ctor">
            <summary>
            Creates a new truncation overflow behavior instance
            </summary>
        </member>
        <member name="T:PowerArgs.SmartWrapOverflowBehavior">
            <summary>
            A class that indicates that the target column should wrap if needed
            </summary>
        </member>
        <member name="P:PowerArgs.SmartWrapOverflowBehavior.MaxWidthBeforeWrapping">
            <summary>
            The max length a cell value can be before it needs to wrap
            </summary>
        </member>
        <member name="P:PowerArgs.SmartWrapOverflowBehavior.WordBreakLookBehind">
            <summary>
            How far back to look for a whitespace character so that wrapping can be done on a word
            </summary>
        </member>
        <member name="P:PowerArgs.SmartWrapOverflowBehavior.DefineMaxWidthBasedOnConsoleWidth">
            <summary>
            If set to true then the target column will have its width dynamically determined based on the width of the current console.  
            You can only set this to true for the last column in a table.
            </summary>
        </member>
        <member name="M:PowerArgs.SmartWrapOverflowBehavior.#ctor">
            <summary>
            Creates a new smart wrap behavior
            </summary>
        </member>
        <member name="T:PowerArgs.ArgRevivers">
            <summary>
            A class that knows how to revive .NET objects from strings provided on the command line
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRevivers.CanRevive(System.Type)">
            <summary>
            Returns true if the given type can be revived, false otherwise
            </summary>
            <param name="t">The type to test</param>
            <returns>true if the given type can be revived, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ArgRevivers.Revive(System.Type,System.String,System.String)">
            <summary>
            Revives the given string into the desired .NET type
            </summary>
            <param name="t">The type to revive to</param>
            <param name="name">the name of the argument</param>
            <param name="value">The string value to revive</param>
            <returns>A revived object of the desired type</returns>
        </member>
        <member name="M:PowerArgs.ArgRevivers.SetReviver(System.Type,System.Func{System.String,System.String,System.Object})">
            <summary>
            Sets the reviver function for a given type, overriding any existing reviver that may exist.
            </summary>
            <param name="t">The type of object the reviver function can revive</param>
            <param name="reviverFunc">the function that revives a command line string, converting it into a consumable object</param>
        </member>
        <member name="M:PowerArgs.ArgRevivers.SetReviver``1(System.Func{System.String,System.String,``0})">
            <summary>
            Sets the reviver function for a given type, overriding any existing reviver that may exist.
            </summary>
            <typeparam name="T">The type of object the reviver function can revive</typeparam>
            <param name="reviverFunc">the function that revives a command line string, converting it into a consumable object</param>
        </member>
        <member name="T:PowerArgs.Args">
            <summary>
            The main entry point for PowerArgs that includes the public parsing functions such as Parse, ParseAction, and InvokeAction.
            </summary>
        </member>
        <member name="M:PowerArgs.Args.GetAmbientDefinition">
            <summary>
            Gets the last definition parsed on the current thread or null if none was parsed.
            </summary>
            <returns>last definition parsed on the current thread or null if none was parsed</returns>
        </member>
        <member name="M:PowerArgs.Args.SearchAssemblyForRevivers(System.Reflection.Assembly)">
            <summary>
            PowerArgs will manually search the assembly you provide for any custom type revivers.  If you don't specify an
            assembly then the assembly that calls this function will automatically be searched.
            </summary>
            <param name="a">The assembly to search or null if you want PowerArgs to search the assembly that's calling into this function.</param>
        </member>
        <member name="M:PowerArgs.Args.Convert(System.String)">
            <summary>
            Converts a single string that represents a command line to be executed into a string[], 
            accounting for quoted arguments that may or may not contain spaces.
            </summary>
            <param name="commandLine">The raw arguments as a single string</param>
            <returns>a converted string array with the arguments properly broken up</returns>
        </member>
        <member name="M:PowerArgs.Args.GetAmbientArgs``1">
            <summary>
            Gets the last instance of this type of argument that was parsed on the current thread
            or null if PowerArgs did not parse an object of this type.
            </summary>
            <typeparam name="T">The scaffold type for your arguments</typeparam>
            <returns>the last instance of this type of argument that was parsed on the current thread</returns>
        </member>
        <member name="M:PowerArgs.Args.GetAmbientArgs(System.Type)">
            <summary>
            Gets the last instance of this type of argument that was parsed on the current thread
            or null if PowerArgs did not parse an object of this type.
            </summary>
            <param name="t">The scaffold type for your arguments</param>
            <returns>the last instance of this type of argument that was parsed on the current thread</returns>
        </member>
        <member name="M:PowerArgs.Args.InitializeDefaults(System.Object)">
            <summary>
            If properties on the given object contain default value attributes then this method will initalize those properties with
            the right defaults
            </summary>
            <param name="o">the object to initialize</param>
        </member>
        <member name="M:PowerArgs.Args.ParseAction(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Parses the given arguments using a command line arguments definition.  
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and/or actions.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>An object containing parser metadata</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseActionAsync(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Asynchronously parses the given arguments using a command line arguments definition.  
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and/or actions.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>An object containing parser metadata</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMain(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Parses the args for the given definition and then calls the Main() method defined by the type.
            </summary>
            <param name="definition">The command line definition to parse</param>
            <param name="args">the command line values</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMainAsync(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Asynchronously parses the args for the given definition and then calls the Main() method defined by the type.
            </summary>
            <param name="definition">The command line definition to parse</param>
            <param name="args">the command line values</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeAction(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Parses the given arguments using a command line arguments definition.  Then, invokes the action
            that was specified.  
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and actions.</param>
            <param name="args">the command line values</param>
            <returns>The raw result of the parse with metadata about the specified action.  The action is executed before returning.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeActionAsync(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Asynchronously parses the given arguments using a command line arguments definition.  Then, invokes the action
            that was specified. 
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and actions.</param>
            <param name="args">the command line values</param>
            <returns>The raw result of the parse with metadata about the specified action.  The action is executed before returning.</returns>
        </member>
        <member name="M:PowerArgs.Args.Parse(System.Type,System.String[])">
            <summary>
            Creates a new instance of the given type and populates it's properties based on the given arguments.
            </summary>
            <param name="t">The argument scaffold type</param>
            <param name="args">The command line arguments to parse</param>
            <returns>A new instance of the given type with all of the properties correctly populated</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseAsync(System.Type,System.String[])">
            <summary>
            Asynchronously creates a new instance of the given type and populates it's properties based on the given arguments.
            </summary>
            <param name="t">The argument scaffold type</param>
            <param name="args">The command line arguments to parse</param>
            <returns>A new instance of the given type with all of the properties correctly populated</returns>
        </member>
        <member name="M:PowerArgs.Args.Parse``1(System.String[])">
            <summary>
            Creates a new instance of T and populates it's properties based on the given arguments.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>A new instance of T with all of the properties correctly populated</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseAsync``1(System.String[])">
            <summary>
            Asynchronously creates a new instance of T and populates it's properties based on the given arguments.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>A new instance of T with all of the properties correctly populated</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseAction``1(System.String[])">
            <summary>
            Creates a new instance of T and populates it's properties based on the given arguments.
            If T correctly implements the heuristics for Actions (or sub commands) then the complex property
            that represents the options of a sub command are also populated.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseActionAsync``1(System.String[])">
            <summary>
            Asynchronously creates a new instance of T and populates it's properties based on the given arguments.
            If T correctly implements the heuristics for Actions (or sub commands) then the complex property
            that represents the options of a sub command are also populated.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseAction(System.Type,System.String[])">
            <summary>
            Creates a new instance of the given type and populates it's properties based on the given arguments.
            If the type correctly implements the heuristics for Actions (or sub commands) then the complex property
            that represents the options of a sub command are also populated.
            </summary>
            <param name="t">The argument scaffold type.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.ParseActionAsync(System.Type,System.String[])">
            <summary>
            Asynchronously creates a new instance of the given type and populates it's properties based on the given arguments.
            If the type correctly implements the heuristics for Actions (or sub commands) then the complex property
            that represents the options of a sub command are also populated.
            </summary>
            <param name="t">The argument scaffold type.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMain(System.Type,System.String[])">
            <summary>
            Parses the args for the given scaffold type and then calls the Main() method defined by the type.
            </summary>
            <param name="t">The argument scaffold type.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMainAsync(System.Type,System.String[])">
            <summary>
            Parses the args for the given scaffold type and then calls the Main() method defined by the type.
            </summary>
            <param name="t">The argument scaffold type.</param>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMain``1(System.String[])">
            <summary>
            Parses the args for the given scaffold type and then calls the Main() method defined by the type.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeMainAsync``1(System.String[])">
            <summary>
            Parses the args for the given scaffold type and then calls the Main() method defined by the type.
            </summary>
            <typeparam name="T">The argument scaffold type.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeAction``1(System.String[])">
            <summary>
            Creates a new instance of T and populates it's properties based on the given arguments. T must correctly
            implement the heuristics for Actions (or sub commands) because this method will not only detect the action
            specified on the command line, but will also find and execute the method that implements the action.
            </summary>
            <typeparam name="T">The argument scaffold type that must properly implement at least one action.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.  The action is executed before returning.</returns>
        </member>
        <member name="M:PowerArgs.Args.InvokeActionAsync``1(System.String[])">
            <summary>
            Asynchronously creates a new instance of T and populates it's properties based on the given arguments. T must correctly
            implement the heuristics for Actions (or sub commands) because this method will not only detect the action
            specified on the command line, but will also find and execute the method that implements the action.
            </summary>
            <typeparam name="T">The argument scaffold type that must properly implement at least one action.</typeparam>
            <param name="args">The command line arguments to parse</param>
            <returns>The raw result of the parse with metadata about the specified action.  The action is executed before returning.</returns>
        </member>
        <member name="M:PowerArgs.Args.Parse(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Parses the given arguments using a command line arguments definition. The values will be populated within
            the definition.
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and/or actions.</param>
            <param name="args">The command line arguments to parse</param>
        </member>
        <member name="M:PowerArgs.Args.ParseAsync(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Parses the given arguments using a command line arguments definition. The values will be populated within
            the definition.
            </summary>
            <param name="definition">The definition that defines a set of command line arguments and/or actions.</param>
            <param name="args">The command line arguments to parse</param>
        </member>
        <member name="T:PowerArgs.ArgUsageOptions">
            <summary>
            A class that lets you customize how your usage displays
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.ShowType">
            <summary>
            Set to true if you want to show the type column (true by default)
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.ShowPosition">
            <summary>
            Set to true if you want to show the position column (true by default)
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.ShowPossibleValues">
            <summary>
            Set to true to list possible values (usually for enums, true by default)
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.AppendDefaultValueToDescription">
            <summary>
            Set to true if you want to show default values after the description (true by default)
            </summary>
        </member>
        <member name="P:PowerArgs.ArgUsageOptions.SpecifiedActionOverride">
            <summary>
            Set this to ensure the usage generator only shows usage info for the specified action.  You will typically
            populate this by looking at the ArgException that you're probably catching.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgUsageOptions.#ctor">
            <summary>
            Creates a new instance of ArgUsageOptions
            </summary>
        </member>
        <member name="T:PowerArgs.UsageHook">
            <summary>
            An attribute used to hook into the usage generation process and influence
            the content that is written.
            </summary>
        </member>
        <member name="E:PowerArgs.UsageHook.HookExecuting">
            <summary>
            An event you can subscribe to in the case where you created
            your hook in running code rather than as a declarative attribute.
            </summary>
        </member>
        <member name="M:PowerArgs.UsageHook.BeforeGenerateUsage(PowerArgs.ArgumentUsageInfo)">
            <summary>
            This hook gets called when the property it is attached to is having
            its usage generated.  You can override this method and manipulate the
            properties of the given usage info object.
            </summary>
            <param name="info">An object that you can use to manipulate the usage output.</param>
        </member>
        <member name="T:PowerArgs.ArgumentUsageInfo">
            <summary>
            A class that represents usage info to be written to the console.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Name">
            <summary>
            The name that will be written as part of the usage.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Aliases">
            <summary>
            Aliases for this argument that will be honored by the parser.  This
            includes shortcuts and long form aliases, but can be extended further.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.PossibleValues">
            <summary>
            Possible values for this option.  This is auto populated for enums and includes the description if specified.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.IsRequired">
            <summary>
            Indicates that the argument is required.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Type">
            <summary>
            The friendly type name that will be displayed to the user.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Position">
            <summary>
            The expected position of the argument, or null if not a positioning is not supported for the given argument.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Description">
            <summary>
            The description that will be written as part of the usage.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Ignore">
            <summary>
            If set to true, the argument usage will not be written.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.IsAction">
            <summary>
            True if this is the "Action" property
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.IsActionArgs">
            <summary>
            True if this represents a nested action argument property
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Property">
            <summary>
            The reflected property that this info object represents
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.Argument">
            <summary>
            The command line argument that the system is currently generating usage for
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentUsageInfo.DefaultValue">
            <summary>
            The default value for the argument
            </summary>
        </member>
        <member name="M:PowerArgs.ArgumentUsageInfo.#ctor(PowerArgs.CommandLineArgument)">
            <summary>
            Generate a new info instance given a reflected property. 
            </summary>
            <param name="toAutoGen">The property to use to seed the usage info</param>
        </member>
        <member name="T:PowerArgs.ArgUsage">
            <summary>
            A helper class that generates usage documentation for your command line arguments given a custom argument
            scaffolding type.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgUsage.RegisterHook(System.Reflection.PropertyInfo,PowerArgs.UsageHook)">
            <summary>
            Registers a usage hook for the given property.
            </summary>
            <param name="prop">The property to hook into or null to hook into all properties.</param>
            <param name="hook">The hook implementation.</param>
        </member>
        <member name="M:PowerArgs.ArgUsage.GenerateUsageFromTemplate``1(System.String)">
            <summary>
            Generates a usage document given a template
            </summary>
            <typeparam name="T">The command line argument definition scaffold type</typeparam>
            <param name="template">The template to use or null to use the default template that's built into PowerArgs</param>
            <returns>The usage document</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GenerateUsageFromTemplate(System.Type,System.String)">
            <summary>
            Generates a usage document given a template
            </summary>
            <param name="t">The command line argument definition scaffold type</param>
            <param name="template">The template to use or null to use the default template that's built into PowerArgs</param>
            <returns>The usage document</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GenerateUsageFromTemplate(PowerArgs.CommandLineArgumentsDefinition,System.String,System.String)">
            <summary>
            Generates a usage document given a template
            </summary>
            <param name="def">The object that describes your program</param>
            <param name="template">The template to use or null to use the default template that's built into PowerArgs</param>
            <param name="templateSourceLocation">The source of the template, usually a file name</param>
            <returns>The usage document</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.ShowUsageInBrowser``1(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates web browser friendly usage documentation for your program and opens it using the local machine's default browser.
            </summary>
            <typeparam name="T">The command line argument definition scaffold type</typeparam>
            <param name="template">The template to use or null to use the default browser friendly template that's built into PowerArgs</param>
            <param name="outputFileName">Where to save the output (the browser will open the file from here)</param>
            <param name="deleteFileAfterBrowse">True if the file should be deleted after browsing</param>
            <param name="waitForBrowserExit">True if you'd like this method to block until the browser is closed.  This only works for browsers that start a new process when opened with a document.</param>
            <returns>The usage document as a string</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.ShowUsageInBrowser(PowerArgs.CommandLineArgumentsDefinition,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates web browser friendly usage documentation for your program and opens it using the local machine's default browser.
            </summary>
            <param name="def">The object that describes your program</param>
            <param name="template">The template to use or null to use the default browser friendly template that's built into PowerArgs</param>
            <param name="outputFileName">Where to save the output (the browser will open the file from here)</param>
            <param name="deleteFileAfterBrowse">True if the file should be deleted after browsing</param>
            <param name="waitForBrowserExit">True if you'd like this method to block until the browser is closed.  This only works for browsers that start a new process when opened with a document.</param>
            <returns>The usage document as a string</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GetUsage``1(System.String,PowerArgs.ArgUsageOptions)">
            <summary>
            Generates usage documentation for the given argument scaffold type.
            </summary>
            <typeparam name="T">Your custom argument scaffold type</typeparam>
            <param name="exeName">The name of your program or null if you want PowerArgs to automatically detect it.</param>
            <param name="options">Specify custom usage options</param>
            <returns>the usage documentation as a string</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GetUsage(PowerArgs.CommandLineArgumentsDefinition,System.String,PowerArgs.ArgUsageOptions)">
            <summary>
            Generates usage documentation for the given argument definition.
            </summary>
            <param name="definition">The definition of the command line arguments for a program</param>
            <param name="exeName">The name of your program or null if you want PowerArgs to automatically detect it.</param>
            <param name="options">Specify custom usage options</param>
            <returns>the usage documentation as a string</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GetStyledUsage``1(System.String,PowerArgs.ArgUsageOptions)">
            <summary>
            Generates color styled usage documentation for the given argument scaffold type.  
            </summary>
            <typeparam name="T">Your custom argument scaffold type</typeparam>
            <param name="exeName">The name of your program or null if you want PowerArgs to automatically detect it.</param>
            <param name="options">Specify custom usage options</param>
            <returns>the usage documentation as a styled string that can be printed to the console</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GetStyledUsage(System.Type,System.String,PowerArgs.ArgUsageOptions)">
            <summary>
            Generates color styled usage documentation for the given argument scaffold type.  
            </summary>
            <param name="t">Your custom argument scaffold type</param>
            <param name="exeName">The name of your program or null if you want PowerArgs to automatically detect it.</param>
            <param name="options">Specify custom usage options</param>
            <returns>the usage documentation as a styled string that can be printed to the console</returns>
        </member>
        <member name="M:PowerArgs.ArgUsage.GetStyledUsage(PowerArgs.CommandLineArgumentsDefinition,System.String,PowerArgs.ArgUsageOptions)">
            <summary>
            Generates color styled usage documentation for the given arguments definition.  
            </summary>
            <param name="definition">The definition of the command line arguments for a program</param>
            <param name="exeName">The name of your program or null if you want PowerArgs to automatically detect it.</param>
            <param name="options">Specify custom usage options</param>
            <returns>the usage documentation as a styled string that can be printed to the console</returns>
        </member>
        <member name="T:PowerArgs.EasterEggs.MatrixMode">
            <summary>
            An easter egg that makes all command line output get written in a green themed, futuristic fasion.  Don't use in a real program :).
            Breaking changes are allowed in the PowerArgs.EasterEggs namespace.
            </summary>
        </member>
        <member name="M:PowerArgs.EasterEggs.MatrixMode.Start">
            <summary>
            Starts MatrixMode.
            </summary>
            <returns>An action that when invoked stops MatrixMode.</returns>
        </member>
        <member name="T:PowerArgs.ArgException">
            <summary>
            An exception that should be thrown when the error condition is caused because of bad user input.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgException.Context">
            <summary>
            The parser context that may be incomplete since it depends on where the exception was thrown
            </summary>
        </member>
        <member name="M:PowerArgs.ArgException.#ctor(System.String)">
            <summary>
            Creates a new ArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.ArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new ArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.InvalidArgDefinitionException">
            <summary>
            An exception that should be thrown when the error condition is caused by an improperly formed
            argument scaffold type.  For example if the user specified the same shortcut value for more than one property.
            </summary>
        </member>
        <member name="M:PowerArgs.InvalidArgDefinitionException.#ctor(System.String)">
            <summary>
            Creates a new InvalidArgDefinitionException given a message.
            </summary>
            <param name="msg">An error message.</param>
        </member>
        <member name="M:PowerArgs.InvalidArgDefinitionException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new InvalidArgDefinitionException given a message.
            </summary>
            <param name="msg">An error message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.UnexpectedArgException">
            <summary>
            An exception that should be thrown when an unexpected named|positional argument is found.
            </summary>
        </member>
        <member name="M:PowerArgs.UnexpectedArgException.#ctor(System.String)">
            <summary>
            Creates a new UnexpectedArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.UnexpectedArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new UnexpectedArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.DuplicateArgException">
            <summary>
            An exception that should be thrown when the same argument is repeated.
            </summary>
        </member>
        <member name="M:PowerArgs.DuplicateArgException.#ctor(System.String)">
            <summary>
            Creates a new DuplicateArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.DuplicateArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new DuplicateArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.MissingArgException">
            <summary>
            An exception that should be thrown when a required argument is missing.
            </summary>
        </member>
        <member name="M:PowerArgs.MissingArgException.#ctor(System.String)">
            <summary>
            Creates a new MissingArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.MissingArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new MissingArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.UnknownActionArgException">
            <summary>
            An exception that should be thrown when an unknown action argument is specified.
            </summary>
        </member>
        <member name="M:PowerArgs.UnknownActionArgException.#ctor(System.String)">
            <summary>
            Creates a new UnknownActionArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.UnknownActionArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new UnknownActionArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.QueryInvalidArgException">
            <summary>
            An exception that should be thrown when the query can not be compiled.
            </summary>
        </member>
        <member name="M:PowerArgs.QueryInvalidArgException.#ctor(System.String)">
            <summary>
            Creates a new QueryInvalidArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.QueryInvalidArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new QueryInvalidArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.ValidationArgException">
            <summary>
            An exception that should be thrown when an argument's value is not valid.
            </summary>
        </member>
        <member name="M:PowerArgs.ValidationArgException.#ctor(System.String)">
            <summary>
            Creates a new ValidationArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
        </member>
        <member name="M:PowerArgs.ValidationArgException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new ValidationArgException given a user friendly message
            </summary>
            <param name="msg">A user friendly message.</param>
            <param name="inner">The inner exception that caused the problem</param>
        </member>
        <member name="T:PowerArgs.IConsoleProvider">
            <summary>
            An interface that serves as an abstraction layer for a console implementation.  
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.KeyAvailable">
            <summary>
            Gets whether or not a key is available to be read
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.ForegroundColor">
            <summary>
            Gets or sets the foreground color
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.BackgroundColor">
            <summary>
            Gets or sets the backgrund color
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.CursorLeft">
            <summary>
            Gets or sets the left position of the console cursor
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.CursorTop">
            <summary>
            Gets or sets the top position of the console cursor
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.BufferWidth">
            <summary>
            Gets or sets the buffer width of the console
            </summary>
        </member>
        <member name="P:PowerArgs.IConsoleProvider.WindowHeight">
            <summary>
            Gets or sets the buffer height of the console
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.Write(System.Object)">
            <summary>
            Write's the string representation of the given object to the console
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.WriteLine(System.Object)">
            <summary>
            Write's the string representation of the given object to the console, followed by a newline.
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.Write(PowerArgs.ConsoleString)">
            <summary>
            Writes the given console string to the console, preserving formatting
            </summary>
            <param name="consoleString">The string to write</param>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.Write(PowerArgs.ConsoleCharacter)">
            <summary>
            Writes the given character to the console, preserving formatting
            </summary>
            <param name="consoleCharacter">The character to write</param>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.WriteLine(PowerArgs.ConsoleString)">
            <summary>
            Writes the given console string to the console, followed by a newline, preserving formatting.
            </summary>
            <param name="consoleString">The string to write</param>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.WriteLine">
            <summary>
            Writes a newline to the console
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.Clear">
            <summary>
            Clears the console window
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.Read">
            <summary>
            Reads the next character of input from the console
            </summary>
            <returns>the char or -1 if there is no more input</returns>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.ReadKey(System.Boolean)">
            <summary>
            Reads a key from the console
            </summary>
            <param name="intercept">if true, intercept the key before it is shown on the console</param>
            <returns>info about the key that was pressed</returns>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.ReadKey">
            <summary>
            Reads a key from the console
            </summary>
        </member>
        <member name="M:PowerArgs.IConsoleProvider.ReadLine">
            <summary>
            Reads a line of text from the console
            </summary>
            <returns>a line of text that was read from the console</returns>
        </member>
        <member name="T:PowerArgs.StdConsoleProvider">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.  This is basically a wrapper around the system console.
            </summary>
        </member>
        <member name="P:PowerArgs.StdConsoleProvider.ForegroundColor">
            <summary>
            Gets or sets the console foreground color
            </summary>
        </member>
        <member name="P:PowerArgs.StdConsoleProvider.BackgroundColor">
            <summary>
            Gets or sets the console background color
            </summary>
        </member>
        <member name="P:PowerArgs.StdConsoleProvider.CursorLeft">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="P:PowerArgs.StdConsoleProvider.CursorTop">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="P:PowerArgs.StdConsoleProvider.BufferWidth">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.ReadKey">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <returns>Used for internal implementation, but marked public for testing, please do not use.</returns>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.Write(System.Object)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <param name="output">Used for internal implementation, but marked public for testing, please do not use.</param>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.WriteLine(System.Object)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <param name="output">Used for internal implementation, but marked public for testing, please do not use.</param>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.WriteLine">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.ReadALineOfConsoleOutput(System.Int32)">
            <summary>
            Used for internal implementation, but marked public for testing, please do not use.
            </summary>
            <param name="y">Used for internal implementation, but marked public for testing, please do not use.</param>
            <returns>Used for internal implementation, but marked public for testing, please do not use.</returns>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.Clear">
            <summary>
            Clears the console
            </summary>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.Read">
            <summary>
            Reads the next character of input from the console
            </summary>
            <returns>the char or -1 if there is no more input</returns>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.ReadKey(System.Boolean)">
            <summary>
            Reads a key from the console
            </summary>
            <param name="intercept">if true, intercept the key before it is shown on the console</param>
            <returns>info about the key that was pressed</returns>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.ReadLine">
            <summary>
            Reads a line of text from the console
            </summary>
            <returns>a line of text that was read from the console</returns>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.Write(PowerArgs.ConsoleString)">
            <summary>
            Writes the given string to the console
            </summary>
            <param name="consoleString">the string to write</param>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.WriteLine(PowerArgs.ConsoleString)">
            <summary>
            Writes the given string to the console, followed by a newline
            </summary>
            <param name="consoleString">the string to write</param>
        </member>
        <member name="M:PowerArgs.StdConsoleProvider.Write(PowerArgs.ConsoleCharacter)">
            <summary>
            Writes the given character to the console
            </summary>
            <param name="consoleCharacter">the character to write</param>
        </member>
        <member name="T:PowerArgs.ActionDebouncer">
            <summary>
            A class that can be used to ensure an action only fires after a burst of triggers ends.
            </summary>
        </member>
        <member name="P:PowerArgs.ActionDebouncer.BurstTimeWindow">
            <summary>
            Gets or sets the burst time window duration used to debounce multiple triggers
            </summary>
        </member>
        <member name="M:PowerArgs.ActionDebouncer.#ctor(System.TimeSpan,System.Action)">
            <summary>
            Creates the debouncer given a bust time window and an action callback.
            </summary>
            <param name="burstTimeWindow">The time span that determines the time window.  When a trigger fires, the debouncer will wait this amount of time before executing the callback.  If a trigger fires before the time elapses, the timer is reset.</param>
            <param name="callback">The action to execute when a trigger fires and the burst time window elapses.</param>
        </member>
        <member name="M:PowerArgs.ActionDebouncer.Trigger">
            <summary>
            Triggers a burst.  If this is the first trigger in a burst of events then a countdown of duration BurstTimeWindow begins.  If this trigger occurs
            while the countdown is in the process of counting to zero then the countdown is reset.  If the countdown ever hits zero then the callback fires
            and the burst is complete.
            </summary>
        </member>
        <member name="T:PowerArgs.ICanBeAConsoleString">
            <summary>
            An interface that defines an object that implements ToConsoleString
            </summary>
        </member>
        <member name="M:PowerArgs.ICanBeAConsoleString.ToConsoleString">
            <summary>
            Formats this object as a ConsoleString
            </summary>
            <returns>a ConsoleString</returns>
        </member>
        <member name="T:PowerArgs.ITabCompletionSource">
            <summary>
            An interface used to implement custom tab completion logic.
            </summary>
        </member>
        <member name="M:PowerArgs.ITabCompletionSource.TryComplete(System.Boolean,System.String,System.String@)">
            <summary>
            PowerArgs will call this method if it has enhanced the command prompt and the user presses tab.  You should use the
            text the user has types so far to determine if there is a completion you'd like to make.  If you find a completion
            then you should assign it to the completion variable and return true.
            </summary>
            <param name="shift">Indicates if shift was being pressed</param>
            <param name="soFar">The text token that the user has typed before pressing tab.</param>
            <param name="completion">The variable that you should assign the completed string to if you find a match.</param>
            <returns>True if you completed the string, false otherwise.</returns>
        </member>
        <member name="T:PowerArgs.ISmartTabCompletionSource">
            <summary>
            A replacement for ITabCompletionSource that makes it easier to implement custom tab completion logic
            </summary>
        </member>
        <member name="M:PowerArgs.ISmartTabCompletionSource.TryComplete(PowerArgs.TabCompletionContext,System.String@)">
            <summary>
            PowerArgs will call this method if it has enhanced the command prompt and the user presses tab.  The 
            context object passed into the function will contain useful information about what the user has typed on the command line.
            If you find a completion then you should assign it to the completion variable and return true.
            </summary>
            <param name="context">An object containing useful information about what the user has typed on the command line</param>
            <param name="completion">The variable that you should assign the completed string to if you find a match.</param>
            <returns>True if you completed the string, false otherwise.</returns>
        </member>
        <member name="T:PowerArgs.TabCompletionContext">
            <summary>
            A class that contains useful information when performing custom tab completion logic
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.Shift">
            <summary>
            Gets whether or not the shift key was down when the tab key was pressed
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.PreviousToken">
            <summary>
            Gets the token that comes before the completion candidate on the command line
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.CommandLineText">
            <summary>
            Gets the full and current state of the command line text
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.Position">
            <summary>
            Gets the position of the cursor within the current command line
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.CompletionCandidate">
            <summary>
            Gets the token that is being considered for tab completion
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.TargetArgument">
            <summary>
            Gets the current command line argument that is being targeted based on the current state of the command line
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.TargetAction">
            <summary>
            Gets the current command line action that is being targeted based on the current state of the command line
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletionContext.Definition">
            <summary>
            Gets a reference to the command line arguments definition being processed
            </summary>
        </member>
        <member name="T:PowerArgs.IUsageTemplateProvider">
            <summary>
            An interface that defines how usage templates should be retrieved
            </summary>
        </member>
        <member name="M:PowerArgs.IUsageTemplateProvider.GetTemplate">
            <summary>
            Gets the usage template to render
            </summary>
            <returns>usage template to render</returns>
        </member>
        <member name="T:PowerArgs.DefaultConsoleUsageTemplateProvider">
            <summary>
            A usage template provider that returns the default console usage template
            </summary>
        </member>
        <member name="M:PowerArgs.DefaultConsoleUsageTemplateProvider.GetTemplate">
            <summary>
            gets the default console usage template
            </summary>
            <returns>the default console usage template</returns>
        </member>
        <member name="T:PowerArgs.DefaultBrowserUsageTemplateProvider">
            <summary>
            A usage template provider that returns the default browser usage template
            </summary>
        </member>
        <member name="M:PowerArgs.DefaultBrowserUsageTemplateProvider.GetTemplate">
            <summary>
            gets the default browser usage template
            </summary>
            <returns>the default browser usage template</returns>
        </member>
        <member name="T:PowerArgs.ParseResult">
            <summary>
            The raw parse result that contains the dictionary of values that were parsed
            </summary>
        </member>
        <member name="P:PowerArgs.ParseResult.ExplicitParameters">
            <summary>
            Dictionary of values that were either in the format -key value or /key:value on
            the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ParseResult.ImplicitParameters">
            <summary>
            Dictionary of values that were implicitly specified by position where the key is the position (e.g. 0)
            and the value is the actual parameter value.
            
            Example command line:  Program.exe John Smith
            
            John would be an implicit parameter at position 0.
            Smith would be an implicit parameter at position 1.
            </summary>
        </member>
        <member name="P:PowerArgs.ParseResult.AdditionalExplicitParameters">
            <summary>
            This is only populated for programs that support multiple command line arguments mapping to a single logical argument.  For example, 
            you may have an argument called -files that you would want to be used like this: -files file1 file2 file3.
            In this case, this dictionary would contain an entry with key 'files' and values 'file2, file3'.  Note that file1 will be populated
            in ExplicitParameters for legacy reasons
            </summary>
        </member>
        <member name="T:PowerArgs.Preview.ArgPipeline">
            <summary>
            A hook that enables the ArgPipeline capabilities.
            </summary>
        </member>
        <member name="F:PowerArgs.Preview.ArgPipeline.PowerArgsPipeIndicator">
            <summary>
            Indicates that the commands surrounding the indicator should be connected in a pipeline
            </summary>
        </member>
        <member name="F:PowerArgs.Preview.ArgPipeline.PipelineStageActionIndicator">
            <summary>
            The standard prefix for a cross cutting, pipeline stage action (e.g. $filter)
            </summary>
        </member>
        <member name="E:PowerArgs.Preview.ArgPipeline.ObjectExitedPipeline">
            <summary>
            This event is fired when the last stage in a pipeline pushes out an object.  The parameter is the object that was
            pushed through the pipeline.
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.ArgPipeline.CommandLineDefinitionFactoryType">
            <summary>
            Gets or sets a Type that must implement ICommandLineArgumentsDefinitionFactory and must provide a default constructor.
            The resulting factory will be used to create new definitions when dynamically invoking pipeline stages.  The default factory 
            can support and command line definition that was created from a .NET type.  You should only have to use this in very advanced scenarios.
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.ArgPipeline.#ctor">
            <summary>
            Creates a new ArgPipeline instance
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.ArgPipeline.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            This is the main hook point where the pipeline features get injected.  This method is responsible for creating the pipeline if needed.  It is also
            responsible for connecting to an external program if this program was launched by another program's pipeline manager.  It is also responsible for
            supporting any pipeline stage actions (e.g. $filter) that are not supported if the [ArgPipeline] metadata is omitted from the root definition.
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.Preview.ArgPipeline.AfterInvoke(PowerArgs.ArgHook.HookContext)">
            <summary>
            If the given context contains the pipeline manager then this method will make sure the 
            pipeline is drained before returning.
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.Preview.ArgPipeline.Push(System.Object)">
            <summary>
            Use this method to push an object to the next stage in the current pipeline.  If there is no
            pipeline currently setup or there is no next stage then the object exits the pipeline and can be
            processed via the ArgPipeline.ObjectExitedPipeline event.
            </summary>
            <param name="o">The object to push through the pipeline</param>
        </member>
        <member name="M:PowerArgs.Preview.ArgPipeline.Push(System.Object,PowerArgs.Preview.PipelineStage)">
            <summary>
            Use this method to push an object to the given pipeline stage's next stage.  You should only use this
            for advanced scenarios where you're processing objects on a thread that was not created for you by
            PowerArgs.  If you're doing that and find the need to use this method, cool :).
            </summary>
            <param name="o">The object to push</param>
            <param name="current">The current pipeline stage.  The object is pushed to the next stage.</param>
        </member>
        <member name="T:PowerArgs.Preview.Collapse">
            <summary>
            An implementation of a pipeline stage that collapses all objects that have been accepted into a list and then pushes the list through the pipeline
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.Collapse.#ctor(System.String[])">
            <summary>
            Creates a Collapse stage
            </summary>
            <param name="commandLine"></param>
        </member>
        <member name="M:PowerArgs.Preview.Collapse.OnObjectReceived(System.Object)">
            <summary>
            Stores the object
            </summary>
            <param name="o">The object to store</param>
        </member>
        <member name="M:PowerArgs.Preview.Collapse.BeforeSetDrainedToTrue">
            <summary>
            Pushes the list of stored objects through the pipeline
            </summary>
        </member>
        <member name="T:PowerArgs.Preview.Expand">
            <summary>
            A pipeline stage that expands the inumerable objects into individual objects and pushes them thorough the pipeline
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.Expand.#ctor(System.String[])">
            <summary>
            Creates an expand stage
            </summary>
            <param name="commandLine">no command line arguments are supported.  You should always pass an empty array</param>
        </member>
        <member name="M:PowerArgs.Preview.Expand.OnObjectReceived(System.Object)">
            <summary>
            Non enumerable objects pass through.  Enumerable objects are enumerated and each item is passed through.
            </summary>
            <param name="o">The object to process</param>
        </member>
        <member name="T:PowerArgs.Preview.Count">
            <summary>
            A pipeline stage that counts the objects that have been pushed through it
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.Count.#ctor(System.String[])">
            <summary>
            Creates a new Count stage
            </summary>
            <param name="commandLine">no command line arguments are supported.  You should always pass an empty array</param>
        </member>
        <member name="M:PowerArgs.Preview.Count.OnObjectReceived(System.Object)">
            <summary>
            Increments the count
            </summary>
            <param name="o">The object passed through the pipeline</param>
        </member>
        <member name="M:PowerArgs.Preview.Count.BeforeSetDrainedToTrue">
            <summary>
            Pushes the count through the pipeline
            </summary>
        </member>
        <member name="T:PowerArgs.Preview.FilterOperators">
            <summary>
            Represents the filter operations supported by the $filter pipeline action stage
            </summary>
        </member>
        <member name="F:PowerArgs.Preview.FilterOperators.Equals">
            <summary>
            Equals
            </summary>
        </member>
        <member name="F:PowerArgs.Preview.FilterOperators.GreaterThan">
            <summary>
            Greater than
            </summary>
        </member>
        <member name="F:PowerArgs.Preview.FilterOperators.LessThan">
            <summary>
            Less than
            </summary>
        </member>
        <member name="F:PowerArgs.Preview.FilterOperators.GreaterThanOrEqualTo">
            <summary>
            Greater than or equal to
            </summary>
        </member>
        <member name="F:PowerArgs.Preview.FilterOperators.LessThanOrEqualTo">
            <summary>
            Less than or equal to
            </summary>
        </member>
        <member name="F:PowerArgs.Preview.FilterOperators.NotEquals">
            <summary>
            Not equals
            </summary>
        </member>
        <member name="F:PowerArgs.Preview.FilterOperators.Contains">
            <summary>
            Contains
            </summary>
        </member>
        <member name="F:PowerArgs.Preview.FilterOperators.NotContains">
            <summary>
            Not contains
            </summary>
        </member>
        <member name="T:PowerArgs.Preview.FilterLogic">
            <summary>
            Only marked public for testing.  Please do not use.
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.FilterLogic.FilterAcceptsObject(System.Object,PowerArgs.Preview.FilterOperators,System.Object)">
            <summary>
            Only marked public for testing.  Please do not use.
            </summary>
            <param name="firstOperand">Only marked public for testing.  Please do not use.</param>
            <param name="filterOperator">Only marked public for testing.  Please do not use.</param>
            <param name="secondOperand">Only marked public for testing.  Please do not use.</param>
            <returns>Only marked public for testing.  Please do not use.</returns>
        </member>
        <member name="T:PowerArgs.Preview.Table">
            <summary>
            A pipeline stage that stores all pipeline input and then formats them as a console table when the stage is drained.
            </summary>
        </member>
        <member name="E:PowerArgs.Preview.Table.TableWritten">
            <summary>
            Mostly used for testing.  An event that fires whenever a Table stage writes a table.
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.Table.#ctor(System.String[])">
            <summary>
            Creates a table stage
            </summary>
            <param name="commandLine">The arguments to be sent to the table expression (See TableExpression documentation).  You can also include an argument
            anywhere in the array with the value '$PassThrough' to indicate that pipeline objects should be forwarded to the next stage in the pipeline.</param>
        </member>
        <member name="M:PowerArgs.Preview.Table.OnObjectReceived(System.Object)">
            <summary>
            Stores the incoming object
            </summary>
            <param name="o">a pipeline object</param>
        </member>
        <member name="M:PowerArgs.Preview.Table.BeforeSetDrainedToTrue">
            <summary>
            Writes the table and optionally passes the objects through
            </summary>
        </member>
        <member name="T:PowerArgs.Preview.ArgPipelineManager">
            <summary>
            A class that manages a pipeline that lets pipeline stages comminicate with each other
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.ArgPipelineManager.Stages">
            <summary>
            Gets a read only collection of stages in this pipeline
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.ArgPipelineManager.IsDrained">
            <summary>
            Returns true if the entire pipeline is drained, false otherwise
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.ArgPipelineManager.BubbleAsyncException(System.Exception)">
            <summary>
            When pipeline stages encounter an exception they should report them to this method so that they can be propagated to the original caller.  This is
            because you can't be sure your stage is running on the same thread as the original caller.
            </summary>
            <param name="ex">The exception to propagate</param>
        </member>
        <member name="T:PowerArgs.Preview.IArgPipelineObjectMapper">
            <summary>
            An interface that defines how objects are mapped when being passed along a pipeline
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.IArgPipelineObjectMapper.MapIncompatibleDirectTargets(System.Type,System.Object)">
            <summary>
            Convert the given incompatible object to the desired type.  This is used when a pipeline stage receives an object that is of a different type
            than it expects.  PowerArgs has a built in algorithm for doing this type of mapping, but you may find the need to customize it.
            </summary>
            <param name="desiredType">The type of object that the caller would like to be returned</param>
            <param name="incompatibleObject">The object that needs to be converted</param>
            <returns>The converted, compatible object</returns>
        </member>
        <member name="M:PowerArgs.Preview.IArgPipelineObjectMapper.TryExtractObjectPropertyIntoCommandLineArgument(System.Object,PowerArgs.CommandLineArgument,System.String[],System.String@,System.String@)">
            <summary>
            Implementers should try to look at the given object and extract a string key and value that corresponds to the given CommandLineArgument. This is used
            when a pipeline stage receives an object and that stage does not define an explicit pipeline target.  In this case we need to find a way to individually map the object
            to loose command line arguments in the target stage.
            </summary>
            <param name="o">The pipeline object</param>
            <param name="argument">The argument we're attempting to extract</param>
            <param name="staticMappings">A static set of mappings that you should honor when trying to map properties on the pipeline object.  You may be passed a null for this</param>
            <param name="commandLineKey">The extracted command line key that should be populated if you return true</param>
            <param name="commandLineValue">The extracted command line value that should be populated if you return true</param>
            <returns>True if an argument was successfully extracted, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.Preview.ArgPipelineObjectMapper">
            <summary>
            Provides a way to get to the current mapper
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.ArgPipelineObjectMapper.CurrentMapper">
            <summary>
            Gets or sets the current pipeline object mapper.  By default, PowerArgs does not set this.
            </summary>
        </member>
        <member name="T:PowerArgs.Preview.ArgPipelineExtractor">
            <summary>
            An attribute that lets you declare that a particular argument can be populated from a pipeline object's property whose name is not
            one of the argument's supported command line aliases. For example if you had a command line argument with default alias 'CustomerId' and an
            object came into the pipeline with a property called 'Id' then you might want to allow that mapping.  In this case you would add the following attribute to your argument:
            
            [ArgPipelineExtractor("Id")]
            public string CustomerId { get; set; }
            
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.ArgPipelineExtractor.StaticMappings">
            <summary>
            The static mappings that were provided to the constructor
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.ArgPipelineExtractor.#ctor(System.String[])">
            <summary>
            Creates a new ArgPipelineExtractor instance.
            </summary>
            <param name="staticMappings">The static string mappings to allow</param>
        </member>
        <member name="T:PowerArgs.Preview.ArgPipelineActionStage">
            <summary>
            An attribute that lets you declare that the target class implements a pipeline action stage like the $filter stage that's
            provided by default.  Use this when building your own action stages.
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.ArgPipelineActionStage.Key">
            <summary>
            Gets the key to this action stage (e.g. "$filter" for the $filter stage)
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.ArgPipelineActionStage.#ctor(System.String)">
            <summary>
            Creates a new stage attribute with the given key.  If the given value doesn't start with a '$' then it
            will be added for you.  The key will also be converted to lowercase.
            </summary>
            <param name="key">The action key (e.g. "$filter" for the $filter stage)</param>
        </member>
        <member name="M:PowerArgs.Preview.ArgPipelineActionStage.RegisterActionStages(System.Reflection.Assembly)">
            <summary>
            Searches the given assembly for types that implement PipelineStage and have the [ArgPipelineActionStage] attribute.  It then
            registers the given stage with the system so that they can be used by end users in their pipelines.
            </summary>
            <param name="a">The assembly to search</param>
        </member>
        <member name="M:PowerArgs.Preview.ArgPipelineActionStage.RegisterActionStage(System.String,System.Type)">
            <summary>
            Explicitly registers an action stage given a key and a corresponding type
            </summary>
            <param name="key">The action key (e.g. "$filter" for the $filter stage)</param>
            <param name="type">The type that implements the stage</param>
        </member>
        <member name="T:PowerArgs.Preview.ArgPipelineTarget">
            <summary>
            Metadata that designates a particular command line argument as an action's direct pipeline target.  When specified any and all pipeline input will
            be used to directly populate the given argument.  That means that any validators and revivers that would normally run on the string representation of the
            argument will not run since the argument will already be 'revived' by virtue of being sent through the pipeline.
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.ArgPipelineTarget.PipelineOnly">
            <summary>
            If true then the target argument can only be populated via the pipeline and therefore should be omitted from usage documentation
            and the target argument does not need to be revivable from a string.
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.ArgPipelineTarget.#ctor">
            <summary>
            Creates a new ArgPipelineTarget instance.
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.ArgPipelineTarget.BeforeValidateDefinition(PowerArgs.ArgHook.HookContext)">
            <summary>
            Makes sure that 'MustBeRevivable' is false for pipeline only arguments
            </summary>
            <param name="context">the processing context</param>
        </member>
        <member name="M:PowerArgs.Preview.ArgPipelineTarget.BeforePrepareUsage(PowerArgs.ArgHook.HookContext)">
            <summary>
            Makes sure that the argument is omitted from usage documentation if it can only be populated from the pipeline
            </summary>
            <param name="context">the processing context</param>
        </member>
        <member name="T:PowerArgs.Preview.ExternalOutputPipelineStageProviderAttribute">
            <summary>
            If you are thinking about using this attribute then you are doing something very advanced.  
            By default, PowerArgs' pipeline feature lets you pipe objects between commands running in the same process.  There is, however, an extensibility point that
            lets you pipe objects between processes.  PowerArgs provides an implementation using a local HTTP listener that you
            can use by adding the nuget package PowerArgs.HttpExternalPipelineProvider.  It is not included by default because it brings in a dependency on Json.NET and 
            I didn't want all PowerArgs users to have to take that dependency.  As long as that DLL is living side by side with PowerArgs.dll then you'll
            get the inter process piping support for free.  This attribute should only be used if you want to provide a different implementation.  You should only need to do that
            if the Http solution does not work for you for some reason.  If that's the case, please submit an issue to GitHub we can discuss your requirements.  Ideally we would
            try our best to make the HTTP solution work for you.  If we can't then I can document this extensibility point.  Keep in mind that if you do build your own implementation
            then only programs that are built with your implementation will be able to pipe objects between each other.
            </summary>
        </member>
        <member name="T:PowerArgs.Preview.ExternalInputPipelineStageProviderAttribute">
            <summary>
            If you are thinking about using this attribute then you are doing something very advanced.  
            By default, PowerArgs' pipeline feature lets you pipe objects between commands running in the same process.  There is, however, an extensibility point that
            lets you pipe objects between processes.  PowerArgs provides an implementation using a local HTTP listener that you
            can use by adding the nuget package PowerArgs.HttpExternalPipelineProvider.  It is not included by default because it brings in a dependency on Json.NET and 
            I didn't want all PowerArgs users to have to take that dependency.  As long as that DLL is living side by side with PowerArgs.dll then you'll
            get the inter process piping support for free.  This attribute should only be used if you want to provide a different implementation.  You should only need to do that
            if the Http solution does not work for you for some reason.  If that's the case, please submit an issue to GitHub we can discuss your requirements.  Ideally we would
            try our best to make the HTTP solution work for you.  If we can't then I can document this extensibility point.  Keep in mind that if you do build your own implementation
            then only programs that are built with your implementation will be able to pipe objects between each other.
            </summary>
        </member>
        <member name="T:PowerArgs.Preview.InProcessPipelineStage">
            <summary>
            A pipeline stage that can run in the current process.  This is the stage used if you are piping beween actions in the same program.
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.InProcessPipelineStage.IsDrained">
            <summary>
            Returns true if the stage is drained, false otherwise.
            </summary>
        </member>
        <member name="E:PowerArgs.Preview.InProcessPipelineStage.UnhandledException">
            <summary>
            An event that gets fired if there's an unhandled exception and there is no pipeline manager attached to this stage.
            If there are no handlers attached to this event and there is no pipeline manager attached then exceptions will bubble to the top of the
            stage's processing therad, and bad things will happen.
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.InProcessPipelineStage.#ctor(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Creates a new in process stage given a base definition and a command line
            </summary>
            <param name="baseDefinition">The definition that describes actions that can be invoked using the given command line</param>
            <param name="commandLine">The command line that represents the structure of this stage</param>
        </member>
        <member name="M:PowerArgs.Preview.InProcessPipelineStage.#ctor(System.String[])">
            <summary>
            Creates a new in process stage given a command line.
            </summary>
            <param name="commandLine">The command line that represents the structure of this stage</param>
        </member>
        <member name="M:PowerArgs.Preview.InProcessPipelineStage.Accept(System.Object)">
            <summary>
            The object is queued up and will be processed by the stage's execution thread.  If this is the first object
            being passed to the stage then the execution thread will be started.
            </summary>
            <param name="o">The object to accept</param>
        </member>
        <member name="M:PowerArgs.Preview.InProcessPipelineStage.Drain">
            <summary>
            asyncronously starts draining this stage.  It returns immediately, but you should not assume that
            IsDrained will return true immediately.  Once this method is called this stage will no longer accept
            objects (it will throw).  Once all queued objects are processed IsDrained will return true.
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.InProcessPipelineStage.BeforeSetDrainedToTrue">
            <summary>
            When overridden by a derived class this method will be called just after we've processed the last queued object (drain has been requested) and just before
            IsDrained is set to true.  This is useful if you're implementing a stage action that needs to have seen all the inputs before outputting it's results (e.g. $count).  This is
            your last opportunity for your stage to write output to the next stage.
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.InProcessPipelineStage.ToString">
            <summary>
            gets a string representation fo this stage
            </summary>
            <returns>a string representation fo this stage</returns>
        </member>
        <member name="M:PowerArgs.Preview.InProcessPipelineStage.OnObjectReceived(System.Object)">
            <summary>
            The default implementation is to use the given definition factory to new up a definition and invoke an action using the given command line.  You can
            override this if you want to process the given pipeline object in a different way.  You will be called on this stage's processing thread and you should let exceptions
            flow through since they'll be bubbled up to the caller directly.
            </summary>
            <param name="o">An object recceived on the pipeline</param>
        </member>
        <member name="T:PowerArgs.Preview.ExternalPipelineInputStage">
            <summary>
            An abstract class that represents a pipeline stage that can be launched from another PowerArgs enabled application.
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.ExternalPipelineInputStage.IsProgramLaunchedByExternalPipeline">
            <summary>
            Gets whether or not this stage has verified that this process has been launched by another application and that the pipeline should
            be connected
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.ExternalPipelineInputStage.#ctor(PowerArgs.CommandLineArgumentsDefinition,System.String[])">
            <summary>
            Creates an instance of the stage given a base definition and a command line
            </summary>
            <param name="baseDefinition">The base definition that declares which actions are supported by this program</param>
            <param name="commandLine">The command line arguments</param>
        </member>
        <member name="T:PowerArgs.Preview.PipelineStage">
            <summary>
            An abstract class that represents a stage in a processing pipeline
            </summary>
        </member>
        <member name="E:PowerArgs.Preview.PipelineStage.Drained">
            <summary>
            An even that fires when this stage is drained.
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.PipelineStage.Current">
            <summary>
            Gets a reference to the Pipeline Stage running on this thread or null if there isn't one
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.PipelineStage.Manager">
            <summary>
            Gets a reference to the pipeline manager that is orchestrating the pipeline or null if there isn't one
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.PipelineStage.NextStage">
            <summary>
            Gets a reference to the next stage in the pipeline or null if there isn't one
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.PipelineStage.CmdLineArgs">
            <summary>
            Gets a read only collection of the command line args that were used to initialize this stage
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.PipelineStage.StageIndex">
            <summary>
            Gets the index of this stage in the pipeline
            </summary>
        </member>
        <member name="P:PowerArgs.Preview.PipelineStage.CommandLineDefinitionFactory">
            <summary>
            Gets a reference to the factory to use if the stage needs to create more instances of the base definition
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.PipelineStage.#ctor(System.String[])">
            <summary>
            Creates a new stage given a set of command line arguments
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:PowerArgs.Preview.PipelineStage.Accept(System.Object)">
            <summary>
            Implementers should choose how to process objects that enter the stage.
            </summary>
            <param name="o"></param>
        </member>
        <member name="P:PowerArgs.Preview.PipelineStage.IsDrained">
            <summary>
            Implementers should return true only after Drain() has been called and the stage has
            finished processing all objects that have been passed to Accept().  
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.PipelineStage.Drain">
            <summary>
            You should not accept any more objects after this is called and PowerArgs should not try to pass you any objects after
            Drain is called.
            </summary>
        </member>
        <member name="M:PowerArgs.Preview.PipelineStage.ToString">
            <summary>
            Gets a string representation of the stage
            </summary>
            <returns>A string representation of the stage</returns>
        </member>
        <member name="M:PowerArgs.Preview.PipelineStage.FireDrained">
            <summary>
            Call this to fire the Drained event
            </summary>
        </member>
        <member name="T:PowerArgs.IPipelineOutputFormatter">
            <summary>
             An interface that lets you define how certain objects should be formatted as ConsoleStrings
            </summary>
        </member>
        <member name="M:PowerArgs.IPipelineOutputFormatter.Format(System.Object)">
            <summary>
            Formats the given object as a ConsoleString
            </summary>
            <param name="o">the object to format</param>
            <returns>The formatted string</returns>
        </member>
        <member name="T:PowerArgs.PipelineOutputFormatterAttribute">
            <summary>
            An attribute that can be used to add custom output formatting for a specific type to your application.  The formatter is used by the pipeline feature.
            </summary>
        </member>
        <member name="P:PowerArgs.PipelineOutputFormatterAttribute.Formatter">
            <summary>
            Gets a reference to the formatter
            </summary>
        </member>
        <member name="M:PowerArgs.PipelineOutputFormatterAttribute.#ctor(System.Type,System.Type)">
            <summary>
            Creates a new formatter for the given target and formatter types
            </summary>
            <param name="targetType">The type of object that this formatter is able to format</param>
            <param name="formatterType">The formatter type that must implement IPipelineOutputFormatter and have a default constructor</param>
        </member>
        <member name="M:PowerArgs.PipelineOutputFormatterAttribute.BeforeInvoke(PowerArgs.ArgHook.HookContext)">
            <summary>
            Registers the formatter
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.PipelineOutputFormatterAttribute.AfterInvoke(PowerArgs.ArgHook.HookContext)">
            <summary>
            Unregisters the formatter
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="T:PowerArgs.FuncPipelineOutputFormatter">
            <summary>
            A class that lets you define a formatter from a Func.
            </summary>
        </member>
        <member name="M:PowerArgs.FuncPipelineOutputFormatter.Create(System.Func{System.Object,PowerArgs.ConsoleString})">
            <summary>
            Creates a formatter from the given implementation
            </summary>
            <param name="impl">The function that implements formatting</param>
        </member>
        <member name="M:PowerArgs.FuncPipelineOutputFormatter.Format(System.Object)">
            <summary>
            Uses the function formatter implementation to format the given object
            </summary>
            <param name="o">The object to format</param>
            <returns>The formatted string</returns>
        </member>
        <member name="T:PowerArgs.PipelineOutputFormatter">
            <summary>
            a static class that can be used to format objects as ConsoleStrings
            </summary>
        </member>
        <member name="M:PowerArgs.PipelineOutputFormatter.Format(System.Object)">
            <summary>
            Formats the given object into a ConsoleString.  If a registered formatter matches the object's type then it is used,
            otherwise the default formatter is used.
            </summary>
            <param name="o">The object to format</param>
            <returns>The formatted string</returns>
        </member>
        <member name="M:PowerArgs.PipelineOutputFormatter.HasFormatter(System.Type)">
            <summary>
            Returns true if the system has a formatter registered for the given type
            </summary>
            <param name="t">the type to check</param>
            <returns>true if the system has a formatter registered for the given type, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.PipelineOutputFormatter.GetFormatter(System.Type)">
            <summary>
            Gets the registered formatter for the given type or null if there isn't one
            </summary>
            <param name="t">The formatter to get</param>
            <returns>the registered formatter for the given type or null if there isn't one</returns>
        </member>
        <member name="M:PowerArgs.PipelineOutputFormatter.UnregisterFormatter(System.Type)">
            <summary>
            Unregisters the formatter for the given type
            </summary>
            <param name="t">The type to unregister</param>
        </member>
        <member name="M:PowerArgs.PipelineOutputFormatter.RegisterFormatter(System.Type,PowerArgs.IPipelineOutputFormatter,System.Boolean)">
            <summary>
            Registers a formatter for the given type
            </summary>
            <param name="t">The type to register for</param>
            <param name="formatter">The formatter implementation</param>
            <param name="allowOverride">If true, this method will allow overriding an existing formatter.  If false, this method throws an exception if a formatter is already registered for the given type.</param>
        </member>
        <member name="T:PowerArgs.PromptIfEmpty">
            <summary>
            A hook that can be put on an argument so that if a user specifies the argument with no value they will get prompted for that value with a rich prompt
            that supports tab completion and syntax highlighting.
            </summary>
        </member>
        <member name="P:PowerArgs.PromptIfEmpty.TabCompletionHandlerType">
            <summary>
            Gets or sets the type to be used for global tab completion.  The type must implement ITabCompletionHandler
            </summary>
        </member>
        <member name="P:PowerArgs.PromptIfEmpty.HighlighterConfiguratorType">
            <summary>
            Gets or sets the type to use inject custom syntax highlighting to the command prompt.  The type must implement IHighlighterConfigurator
            </summary>
        </member>
        <member name="M:PowerArgs.PromptIfEmpty.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            Prompts the user to enter a value for the given property in the case that the option was specified with no value
            </summary>
            <param name="context">the parser context</param>
        </member>
        <member name="T:PowerArgs.ArgProductVersion">
            <summary>
            Use this attribute to describe a version string that can appear in the usage documentation
            </summary>
        </member>
        <member name="P:PowerArgs.ArgProductVersion.Value">
            <summary>
            The copyright value
            </summary>
        </member>
        <member name="M:PowerArgs.ArgProductVersion.#ctor(System.String)">
            <summary>
            Creates a new ArgProductVersion attribute.
            </summary>
            <param name="value">The version value</param>
        </member>
        <member name="T:PowerArgs.ArgProductName">
            <summary>
            Use this attribute to describe your proper program name (which might be longer than exeName). This string that will appear in the usage documentation
            </summary>
        </member>
        <member name="P:PowerArgs.ArgProductName.Value">
            <summary>
            The product name value
            </summary>
        </member>
        <member name="M:PowerArgs.ArgProductName.#ctor(System.String)">
            <summary>
            Creates a new ArgProductName attribute.
            </summary>
            <param name="value">The product name value</param>
        </member>
        <member name="T:PowerArgs.ArgCopyright">
            <summary>
            Use this attribute to describe a copyright string that can appear in the usage documentation
            </summary>
        </member>
        <member name="P:PowerArgs.ArgCopyright.Value">
            <summary>
            The copyright value
            </summary>
        </member>
        <member name="M:PowerArgs.ArgCopyright.#ctor(System.String)">
            <summary>
            Creates a new ArgCopyright attribute.
            </summary>
            <param name="value">The copyright value</param>
        </member>
        <member name="T:PowerArgs.AllowUnexpectedArgs">
            <summary>
            Put this attribute on the class that defines your arguments to specify that PowerArgs
            should allow extra command line values that don't match any explicitly defined arguments.
            Note that this means that PowerArgs will not be able to tell the difference between an extra
            argument and a misspelled argument.  
            </summary>
        </member>
        <member name="T:PowerArgs.ArgContextualAssistant">
            <summary>
            An attribute that you can add to argument properties or parameters that lets you inject custom contextual assistant logic into the PowerArgs enhanced command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgContextualAssistant.ContextAssistProviderType">
            <summary>
            Gets the type to be used for contexual assistance.  It must implement IContextAssistProvider.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgContextualAssistant.#ctor(System.Type)">
            <summary>
            Initializes the metadata given the type that implements IContextAssistProvider.
            </summary>
            <param name="contextAssistProviderType">a type that implements IContextAssistProvider</param>
        </member>
        <member name="T:PowerArgs.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:PowerArgs.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:PowerArgs.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:PowerArgs.Resources.DefaultBrowserUsageTemplate">
             <summary>
               Looks up a localized string similar to &lt;!DOCTYPE html&gt;
            &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
            &lt;head&gt;
                &lt;title&gt;{{ExeName!}} documentation&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;h1 class=&quot;program-specific-content&quot;&gt;{{ExeName!}}&lt;/h1&gt;
                &lt;p class=&quot;program-specific-content&quot;&gt;{{Description!}}&lt;/p&gt;
            
                &lt;h2&gt;Usage&lt;/h2&gt;
            &lt;pre class=&quot;code-sample&quot;&gt;{{UsageSummaryHTMLEncoded!}}&lt;/pre&gt;
            
                {{if HasGlobalArguments}}
                {{if HasActions}}&lt;h2&gt;Global options&lt;/h2&gt;!{{if}}
                {{ifnot HasActions}}&lt;h2&gt;Options&lt;/h2&gt;!{{ifnot}}
            
                &lt;table&gt;
                    &lt;tr&gt;
                   [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:PowerArgs.Resources.DefaultConsoleUsageTemplate">
             <summary>
               Looks up a localized string similar to {{if HasDescription}}
            
            {{ Description !}}
            
            
            !{{if}}
            {{ifnot HasSpecifiedAction}}
            Usage - {{UsageSummary Cyan!}}
            !{{ifnot}}
            {{if HasGlobalArguments}}
            
            {{if HasActions}}Global options!{{if}}{{ifnot HasActions}}Options!{{ifnot}}
            
            {{table Arguments Syntax&gt;Option Description !}}
            !{{if}}
            {{if HasActions}}
            {{if HasSpecifiedAction}}
            
            {{SpecifiedAction.DefaultAlias!}} - {{SpecifiedAction.Description!}}
            
            Usage - {{ExeName Cyan!}} {{SpecifiedAction.UsageSummary Cyan!}}
            
            {{if SpecifiedAction.HasAr [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:PowerArgs.Resources.QueryTemplate">
             <summary>
               Looks up a localized string similar to using System;
            using System.Linq;
            using System.Collections.Generic;
            $Usings$
            
            namespace $Namespace$
            {
                public class $Class$
                {
                    public static List&lt;$ReturnType$&gt; $Method$(IEnumerable&lt;$ReturnType$&gt; source)
                    {
                        IEnumerable&lt;$ReturnType$&gt; query = from item in source select item;
            
                        $WhereComment$              query = from item in query where $Where$ select item;
                        $OrderByDescendingComment$  query = query.OrderByDescending($OrderByDescending$);
                [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="T:PowerArgs.DocumentRendererContext">
            <summary>
            An object that tracks information about document rendering
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentRendererContext.LocalVariables">
            <summary>
            The current set of local variables that can be referenced by a template
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentRendererContext.RootDataObject">
            <summary>
            The root data object that is bound to the document template
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentRendererContext.DocumentRenderer">
            <summary>
            The object that is currently rendering a document
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentRendererContext.#ctor(System.Object)">
            <summary>
            Creates a render context from a root data object
            </summary>
            <param name="rootDataObject">The root data object that will be bound to a template</param>
        </member>
        <member name="M:PowerArgs.DocumentRendererContext.RenderDynamicContent(System.String,PowerArgs.DocumentToken)">
            <summary>
            Dynamically renders the given template.
            </summary>
            <param name="dynamicTemplate">The template to render</param>
            <param name="nestedToken">The token in the original document that resulted in dynamic rendering</param>
            <returns>The rendered content</returns>
        </member>
        <member name="M:PowerArgs.DocumentRendererContext.RenderBody(System.Collections.Generic.IEnumerable{PowerArgs.DocumentToken})">
            <summary>
            Renders the given tokens, which are generally the body of a replacement expression.
            </summary>
            <param name="body">The tokens to render</param>
            <returns>the rendered content</returns>
        </member>
        <member name="M:PowerArgs.DocumentRendererContext.EvaluateExpression(System.String)">
            <summary>
            Evaluates the given expression and returns the result.  The expression can refer to a local variable (e.g. 'somevariable'), 
            a path starting from a localVariable (e.g. 'somevariable.SomeProperty.SomeOtherProperty'), or a path starting from the root
            data object (e.g. if the root was of type 'Person' you could say 'FirstName', assuming the Person type has a property called 'FirstName').
            </summary>
            <param name="expressionText">The expression text</param>
            <returns>The resolved value as a .NET object</returns>
        </member>
        <member name="T:PowerArgs.TemplateExpression">
            <summary>
            A document expression that can render a named template
            </summary>
        </member>
        <member name="P:PowerArgs.TemplateExpression.IdToken">
            <summary>
            A token containing the id of the template to render
            </summary>
        </member>
        <member name="P:PowerArgs.TemplateExpression.EvalToken">
            <summary>
            A token containing an expression to be evaluated.  The result of the evaluation
            will be used as the root data object to be bound to the named template.
            </summary>
        </member>
        <member name="M:PowerArgs.TemplateExpression.#ctor(PowerArgs.DocumentToken,PowerArgs.DocumentToken)">
            <summary>
            Creates a new template expression given an id token and a data evaluation token.
            </summary>
            <param name="idToken">A token containing the id of the template to render</param>
            <param name="evalToken">A token containing an expression to be evaluated.  The result of the evaluation will be
            used as the root data object to be bound to the named template.</param>
        </member>
        <member name="M:PowerArgs.TemplateExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Finds the matching template from the data context, evaluates the data expression, then renders
            the template against the data.  The rendered document is inserted into the parent document.
            </summary>
            <param name="context">The data context used to find the named template and to evaluate the data expression</param>
            <returns>The rendered child document to be inserted into the parent document</returns>
        </member>
        <member name="T:PowerArgs.TemplateExpressionProvider">
            <summary>
            A provider that can create a template expression from a replacement token and parameters.
            </summary>
        </member>
        <member name="M:PowerArgs.TemplateExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Creates a template expression given a replacement token and parameters.
            </summary>
            <param name="context">Context about the expression being parsed</param>
            <returns>a template expression</returns>
        </member>
        <member name="T:PowerArgs.TableExpression">
            <summary>
            A document expression that can be used to render a table that is specifically formatted to display
            in a console window.
            </summary>
        </member>
        <member name="P:PowerArgs.TableExpression.EvalToken">
            <summary>
            The token representing the expression to evaluate.  The expression is expected to resolve to
            an IEnumerable.
            </summary>
        </member>
        <member name="P:PowerArgs.TableExpression.Columns">
            <summary>
            The tokens that represent the columns to display.  Each value is expected to be a property name.  Optionally, you can
            override the display name by appending '>NewDisplayName' to the value.  For example, if there was a property called 'TheName'
            and you wanted it to display as 'Name' then the value of the column token would be 'TheName>Name'.
            </summary>
        </member>
        <member name="P:PowerArgs.TableExpression.ShowPossibleValuesForArguments">
            <summary>
            PowerArgs specific property - Set to false if using outside of Powerargs - If true then properties that are enums 
            will have their values inserted into the table.
            </summary>
        </member>
        <member name="P:PowerArgs.TableExpression.ShowDefaultValuesForArguments">
            <summary>
            PowerArgs specific property - Set to false if using outside of Powerargs - If true then the properties that have a default 
            value will have that inserted into the table
            </summary>
        </member>
        <member name="M:PowerArgs.TableExpression.#ctor(PowerArgs.DocumentToken,System.Collections.Generic.List{PowerArgs.DocumentToken},PowerArgs.DocumentExpressionContext)">
            <summary>
            Creates a new table expression given a collection evaluation expression and a list of column tokens
            </summary>
            <param name="evalToken">A token containing an expression that should evaluate to an IEnumerable</param>
            <param name="columns">A list of tokens containing the names of columns to display in the table</param>
            <param name="context">Context that is used to determine the indentation of the table within the document</param>
        </member>
        <member name="M:PowerArgs.TableExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Renders the table given a data context
            </summary>
            <param name="context">the data context</param>
            <returns>the console friendly table, as a ConsoleString</returns>
        </member>
        <member name="T:PowerArgs.TableExpressionProvider">
            <summary>
            A provider that can create a table expression given a replacement token and parameters.
            </summary>
        </member>
        <member name="M:PowerArgs.TableExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Creates a table expression from the given document info.
            </summary>
            <param name="context">The context that contains information about the document being rendered</param>
            <returns>The created document expression</returns>
        </member>
        <member name="T:PowerArgs.VarExpression">
            <summary>
            An expression that indicates the beginning of a local variable's scope
            </summary>
        </member>
        <member name="P:PowerArgs.VarExpression.NameToken">
            <summary>
            A token containing the name of the local variable to initialize
            </summary>
        </member>
        <member name="P:PowerArgs.VarExpression.ValueToken">
            <summary>
            A token containing an expression that should resolve to the initial value of the variable
            </summary>
        </member>
        <member name="M:PowerArgs.VarExpression.#ctor(PowerArgs.DocumentToken,PowerArgs.DocumentToken)">
            <summary>
            Creates a new variable expression given a name and value expression
            </summary>
            <param name="name">A token containing the name of the local variable to initialize</param>
            <param name="value">A token containing an expression that should resolve to the initial value of the variable</param>
        </member>
        <member name="M:PowerArgs.VarExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Always results in an empty string, but initializes the local value in the data context
            </summary>
            <param name="context">The data context used to store the newly initialized variable</param>
            <returns>an empty string</returns>
        </member>
        <member name="T:PowerArgs.ClearVarExpression">
            <summary>
            An expression that indicates the end of a local variable's scope
            </summary>
        </member>
        <member name="P:PowerArgs.ClearVarExpression.NameToken">
            <summary>
            A token containing the name of the variable whose scope is ending
            </summary>
        </member>
        <member name="M:PowerArgs.ClearVarExpression.#ctor(PowerArgs.DocumentToken)">
            <summary>
            Creates a new clear variable expression given a variable name
            </summary>
            <param name="name">A token containing the name of the variable whose scope is ending</param>
        </member>
        <member name="M:PowerArgs.ClearVarExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Removes the named variable from the context's local variable set
            </summary>
            <param name="context">the context that should contain the local variable to remove</param>
            <returns>an empty string</returns>
        </member>
        <member name="T:PowerArgs.VarExpressionProvider">
            <summary>
            A provider that can create a variable expression
            </summary>
        </member>
        <member name="M:PowerArgs.VarExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Creates a variable expression given replacement info
            </summary>
            <param name="context">The context that contains information about the document being rendered</param>
            <returns>A variable expression</returns>
        </member>
        <member name="T:PowerArgs.ClearVarExpressionProvider">
            <summary>
            A provider that can create an expression to clear a local variable
            </summary>
        </member>
        <member name="M:PowerArgs.ClearVarExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Creates a clear variable expression given replacement info
            </summary>
            <param name="context">The context that contains information about the document being rendered</param>
            <returns>a clear variable expression</returns>
        </member>
        <member name="T:PowerArgs.EvalExpression">
            <summary>
            The core expression that knows how to evaluate C# object expressions like property navigation, including indexed properties.
            </summary>
        </member>
        <member name="P:PowerArgs.EvalExpression.EvalToken">
            <summary>
            Gets the evaluation token that will be evaluated against a data context
            </summary>
        </member>
        <member name="P:PowerArgs.EvalExpression.ForegroundColorToken">
            <summary>
            The optional foreground color token that can be used to customize the color of the resulting value
            </summary>
        </member>
        <member name="P:PowerArgs.EvalExpression.BackgroundColorToken">
            <summary>
            The optional background color token that can be used to customize the color of the resulting value
            </summary>
        </member>
        <member name="P:PowerArgs.EvalExpression.FG">
            <summary>
            Gets the ConsoleColor that matches the provided foreground color token, if it was provided.
            </summary>
        </member>
        <member name="P:PowerArgs.EvalExpression.BG">
            <summary>
            Gets the ConsoleColor that matches the provided background color token, if it was provided.
            </summary>
        </member>
        <member name="M:PowerArgs.EvalExpression.#ctor(PowerArgs.DocumentToken)">
            <summary>
            Creates an eval expression given a token that represents the expression to evaluate
            </summary>
            <param name="evalToken">The token containing the expression to evaluate</param>
        </member>
        <member name="M:PowerArgs.EvalExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Evaluates the evaluation expression against a data context, optionally setting the console color if the expression contains those parameters
            </summary>
            <param name="context">The datta context to evaluate against</param>
            <returns>The result of the evaluation as a ConsoleString</returns>
        </member>
        <member name="T:PowerArgs.EvalExpressionProvider">
            <summary>
            The provider that can create an eval expression from template replacement info
            </summary>
        </member>
        <member name="M:PowerArgs.EvalExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Creates an eval expression given template replacement info
            </summary>
            <param name="context">The context that contains information about the document being rendered</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.EachExpression">
            <summary>
            An expression used to expand a portion of a document template for each element in a collection
            </summary>
        </member>
        <member name="P:PowerArgs.EachExpression.IterationVariableNameToken">
            <summary>
            Gets the token in the document that represents the iteration variable name (e.g. 'element' in {{each element in collection}})
            </summary>
        </member>
        <member name="P:PowerArgs.EachExpression.CollectionVariableExpressionToken">
            <summary>
            Gets the token in the document that represents the collection evaluation expression (e.g. 'collection' in {{each element in collection}})
            </summary>
        </member>
        <member name="P:PowerArgs.EachExpression.Body">
            <summary>
            Gets the body of the each expression.  This body will be evaluated once fore each element in the collection.
            </summary>
        </member>
        <member name="M:PowerArgs.EachExpression.#ctor(PowerArgs.DocumentToken,PowerArgs.DocumentToken,System.Collections.Generic.IEnumerable{PowerArgs.DocumentToken})">
            <summary>
            Creates a new each expression given an iteration variable name, a collection expression, and a body.
            </summary>
            <param name="iterationVariable">The name to assign to ther variable representing the current element in the template</param>
            <param name="collectionExpression">The expression used to determine the collection to enumerate</param>
            <param name="body">The body of the each loop</param>
        </member>
        <member name="M:PowerArgs.EachExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Evaluates the each loop
            </summary>
            <param name="context">The context that contains information about the document being rendered</param>
            <returns>The rendered contents of the each loop</returns>
        </member>
        <member name="T:PowerArgs.EachExpressionProvider">
            <summary>
            A class that can take in document replacement info and convert it into a document expression that represents an each loop.
            </summary>
        </member>
        <member name="M:PowerArgs.EachExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Takes in document replacement info and converts it into a document expression that represents an each loop.
            </summary>
            <param name="context">Context about the expression being parsed</param>
            <returns>The parsed each expression</returns>
        </member>
        <member name="T:PowerArgs.ConsoleColorStackElement">
            <summary>
            An element that can be used to track the state of the renderer's colors as expressions are being evaluated
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleColorStackElement.FG">
            <summary>
            An optional foreground color value
            </summary>
        </member>
        <member name="P:PowerArgs.ConsoleColorStackElement.BG">
            <summary>
            An optional background color value
            </summary>
        </member>
        <member name="T:PowerArgs.LocalVariableSet">
            <summary>
            A class that lets the document renderer track local variable state as expressions are being evaluated
            </summary>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.#ctor">
            <summary>
            Creates a new local variable set
            </summary>
        </member>
        <member name="P:PowerArgs.LocalVariableSet.CurrentForegroundColor">
            <summary>
            Gets the current foreground color that is in scope or null if it is not currently defined
            </summary>
        </member>
        <member name="P:PowerArgs.LocalVariableSet.CurrentBackgroundColor">
            <summary>
            Gets the current background color that is in scope or null if it is not currently defined
            </summary>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.PushConsoleColors(System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Sets the current console color variables to the given values, pushing the existing values onto a stack
            </summary>
            <param name="fg">The optional foreground color to set</param>
            <param name="bg">The optional background color to set</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.PopConsoleColors">
            <summary>
            Pops the latest console colors off of the stack and sets them as the current colors to use.
            </summary>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.Add(PowerArgs.DocumentToken,System.Object)">
            <summary>
            Adds a new local variable.  This will throw if there's already a variable defined with the given identifier
            </summary>
            <param name="variableToken">The token containing the identifier of the variable name</param>
            <param name="value">The initial value of the local variable</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.Force(System.String,System.Object)">
            <summary>
            Forefully sets the value of a local value, regardless of whether or not that variable is already defined.
            </summary>
            <param name="variableName">The name of the variable</param>
            <param name="value">The value of the variable</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.Remove(PowerArgs.DocumentToken)">
            <summary>
            Removes a local variable.  This will throw if there is no variable with the given name
            </summary>
            <param name="variableToken">The token containing the identifier of the variable to remove</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.ForceClear(System.String)">
            <summary>
            Tries to remove a variable, and does not throw if the variable is not defined.
            </summary>
            <param name="variableName">The name of the variable to clear</param>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.IsDefined(System.String)">
            <summary>
            Determines if the given variable is defined
            </summary>
            <param name="variableName">The name to check</param>
            <returns>True if the variable is defined, false otherwise</returns>
        </member>
        <member name="P:PowerArgs.LocalVariableSet.Item(System.String)">
            <summary>
            Gets the value of a local variable given an identifier
            </summary>
            <param name="variableName">the name of the variable to lookup</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.LocalVariableSet.TryParseLocalVariable(System.String,System.Object@,System.String@)">
            <summary>
            Tries to parse a local variable from an expression.  If successful the expression is evaluated then the local variable is returned via an out variable.  
            If there was more to the expression, a property navigation for example, then that is also passed to the caller via an out variable.
            </summary>
            <param name="expression">The expression that may refer to a local variable</param>
            <param name="result">The local variable that is set if a local variable was matched</param>
            <param name="restOfExpression">The rest of the expression that came after the local variable identifier</param>
            <returns>True if a local variable was parsed, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.IDocumentExpressionProvider">
            <summary>
            An object that can take a replacement key, a set of parameters, an optional body, and transform it into a document expression.
            </summary>
        </member>
        <member name="M:PowerArgs.IDocumentExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Transforms document expression context into a document expression
            </summary>
            <param name="context">Context about the expression being parsed</param>
            <returns>The formal expression that can be evaluated into text</returns>
        </member>
        <member name="T:PowerArgs.DocumentExpressionContext">
            <summary>
            An object that contains contextual information that is useful for expression providers
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentExpressionContext.OpenToken">
            <summary>
            The opening token of the replacement expression '{{'
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentExpressionContext.CloseToken">
            <summary>
            The closing topen of the replacement expression '!}}' or '!{{TAG}}'
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentExpressionContext.ReplacementKeyToken">
            <summary>
            The replacement key token.  Example: 'if' in {{ if Foo }}
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentExpressionContext.Parameters">
            <summary>
            The parameters of the replacement.  Example: ["Foo", "Bar"] in '{{ someTag Foo Bar !}}'
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentExpressionContext.Body">
            <summary>
            The body text between the tags.  Not populated if the tag is quick terminated.
            </summary>
        </member>
        <member name="T:PowerArgs.DynamicExpressionProviderAttribute">
            <summary>
            An attribute that can be added to a class that implements IDocumentExpressionProvider.  This attributes indicates that the provider can be
            dynamically registered.
            </summary>
        </member>
        <member name="P:PowerArgs.DynamicExpressionProviderAttribute.Key">
            <summary>
            The replacement key (e.g. 'each' in {{each foo in bar }}) to use when the given provider is registered
            </summary>
        </member>
        <member name="M:PowerArgs.DynamicExpressionProviderAttribute.#ctor(System.String)">
            <summary>
            Creates a new DynamicExpressionProviderAttribute given a key
            </summary>
            <param name="key"></param>
        </member>
        <member name="T:PowerArgs.DocumentExpressionParser">
            <summary>
            A class that can parse a collection of document tokens into a collection of expressions
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentExpressionParser.RegisteredReplacementExpressionProviderKeys">
            <summary>
            Gets a list of registered expression provider keys
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.#ctor">
            <summary>
            Creates a new document expression parser and registers the built in expression provider types.
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.RegisterDynamicReplacementExpressionProviders(System.Reflection.Assembly,System.Boolean)">
            <summary>
            Searches the given assembly for IDocumentExpressionProvider types that have the DynamicExpressionProviderAttribute attribute and registers those providers
            with this parser.  The type needs to have a default constructor.
            </summary>
            <param name="target">The assembly to search</param>
            <param name="allowOverrideExistingKeys">If true, providers with keys that are already exist with override the existing providers.  If false, an exception will be thrown if a conflict is found.</param>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.RegisterReplacementExpressionProvider(System.String,PowerArgs.IDocumentExpressionProvider,System.Boolean)">
            <summary>
            Manually registers the given expression provider using the given key.  
            </summary>
            <param name="replacementKey">The unique key for the replacement provider (e.g. 'each' in {{each foo in bar}}</param>
            <param name="provider">The provider to register</param>
            <param name="allowOverrideExistingKeys">If true, allow this provider to replace an existing provider registered with the same key .  If false, an exception will be thrown if a conflict is found.</param>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.UnregisterReplacementExpressionProvider(System.String)">
            <summary>
            Unregisters the expression provider with the given key
            </summary>
            <param name="replacementKey">The key of the provider to unregister</param>
        </member>
        <member name="M:PowerArgs.DocumentExpressionParser.Parse(System.Collections.Generic.IEnumerable{PowerArgs.DocumentToken})">
            <summary>
            Parses the given tokens into document expressions that can then be evaluated against a data context.
            </summary>
            <param name="tokens">The tokens to parse</param>
            <returns>a list of document expressions</returns>
        </member>
        <member name="T:PowerArgs.PlainTextDocumentExpression">
            <summary>
            A document expression that represents plain text with no replacements or custom logic
            </summary>
        </member>
        <member name="F:PowerArgs.PlainTextDocumentExpression.tokens">
            <summary>
            The plain text tokens
            </summary>
        </member>
        <member name="M:PowerArgs.PlainTextDocumentExpression.#ctor(System.Collections.Generic.List{PowerArgs.DocumentToken})">
            <summary>
            Creates a plain text document expression given a list of tokens
            </summary>
            <param name="tokens">A list of plain text tokens to render without any special handling</param>
        </member>
        <member name="M:PowerArgs.PlainTextDocumentExpression.#ctor(PowerArgs.DocumentToken)">
            <summary>
            Creates a plain text document expression given a single plain text token
            </summary>
            <param name="singleToken">A single plain text token to render without any special handling</param>
        </member>
        <member name="M:PowerArgs.PlainTextDocumentExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Renders the tokens in the expression, using the ambient foreground and background colors if they are set.
            </summary>
            <param name="context">The data context to use for evaluation</param>
            <returns>The rendered plain text</returns>
        </member>
        <member name="T:PowerArgs.TokenReader`1">
            <summary>
            A class that makes it easy to read through a list of tokens
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:PowerArgs.TokenReader`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a token reader given a list of tokens
            </summary>
            <param name="tokens">The list of tokens to read through</param>
        </member>
        <member name="M:PowerArgs.TokenReader`1.Advance(System.Boolean)">
            <summary>
            Advances the reader to the next token
            </summary>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>the next token in the list</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.Peek(System.Boolean)">
            <summary>
            Gets the next token in the list without actually advancing the reader
            </summary>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>The next token in the list</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.TryAdvance(`0@,System.Boolean)">
            <summary>
            Advances the reader to the next token if one exists.
            </summary>
            <param name="ret">The out variable to store the token if it was found</param>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>True if the reader advanced, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.CanAdvance(System.Boolean)">
            <summary>
            Determines if the reader can advance
            </summary>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>True if there is another token to read, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.TryPeek(`0@,System.Int32@,System.Int32,System.Boolean)">
            <summary>
            Reads the next token without advancing if one is available.
            </summary>
            <param name="ret">The out variable to store the token if it was found</param>
            <param name="lastPeekIndex">The out variable to store the index of the peeked token in the token list</param>
            <param name="lookAhead">How far to peek ahead, by default 1</param>
            <param name="skipWhitespace">If true, the reader will skip past whitespace tokens when reading</param>
            <returns>True if the reader peeked at a value, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.ToString">
            <summary>
            Gets all the tokens in the list concatenated into a single string, including whitespace
            </summary>
            <returns>all the tokens in the list concatenated into a single string, including whitespace</returns>
        </member>
        <member name="M:PowerArgs.TokenReader`1.ToString(System.Boolean)">
            <summary>
            Gets all the tokens in the list concatenated into a single string, optionally excluding whitespace
            </summary>
            <param name="skipWhitespace">If true, whitespace tokens will not be included in the output.  Tokens that have
            whitespace and non whitespace characters will always be included</param>
            <returns>all the tokens in the list concatenated into a single string, with whitespace tokens optionally excluded</returns>
        </member>
        <member name="T:PowerArgs.DocumentTokenType">
            <summary>
            An enum defining the types of tokens that can appear in a templated document
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.ReplacementKey">
            <summary>
            Indicates the Key of a replacement tag.  Example: 'each' in '{{each foo in bar}}'
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.ReplacementParameter">
            <summary>
            Indicates a parameter in a replacement tag.  Example: 'foo', 'in', and 'bar' in '{{each foo in bar}}'
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.PlainText">
            <summary>
            Text that is not transformed by the document renderer
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.BeginReplacementSegment">
            <summary>
            Indicates the beginning of a replacement tag '{{'.
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.EndReplacementSegment">
            <summary>
            Indicates the end of a replacement segment '}}'
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.BeginTerminateReplacementSegment">
            <summary>
            Indicates the beginning of a termination segment '!{{'
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentTokenType.QuickTerminateReplacementSegment">
            <summary>
            Indicates that a replacement segment has no body and this is the end of the segment '!}}'
            </summary>
        </member>
        <member name="T:PowerArgs.DocumentToken">
            <summary>
            A class that represents a token in a templated document
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentToken.TokenType">
            <summary>
            The type of this token
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new document token
            </summary>
            <param name="initialValue">The initial value of the token</param>
            <param name="startIndex">the zero based character index of this token in a document template</param>
            <param name="line">The line number of this token in a document template (starts at 1)</param>
            <param name="col">The column number of this token in a document template (starts at 1)</param>
        </member>
        <member name="M:PowerArgs.DocumentToken.GetTokenTypeValue(PowerArgs.DocumentTokenType)">
            <summary>
            Gets the constant string value of a given token type.  This method will throw an exception if the
            type provided does not map to a constant string value.
            </summary>
            <param name="type">The type to lookup</param>
            <returns>The literal string value expected of a token of the given type</returns>
        </member>
        <member name="M:PowerArgs.DocumentToken.TryGetTokenTypeValue(PowerArgs.DocumentTokenType,System.String@)">
            <summary>
            Tries to get the constant string value of a given token type.  This method will return false for types that don't
            map to a constant string value.
            </summary>
            <param name="type">The type to lookup</param>
            <param name="val">The literal string value expected of a token of the given type</param>
            <returns>true if 'val' was populated, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.DocumentToken.TryParseDocumentTokenType(System.String,PowerArgs.DocumentTokenType@)">
            <summary>
            Tries to parse a literal string value to a well known document token type.
            </summary>
            <param name="stringVal">The value to try to parse</param>
            <param name="type">The reference to populate if parsing is successful</param>
            <returns>True if the string could be successfully mapped to a DocumentTokenType, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.DocumentToken.Tokenize(System.String,System.String)">
            <summary>
            Tokenizes the given text into a list of DocumentToken objects.
            </summary>
            <param name="text">The text to tokenize</param>
            <param name="sourceLocation">A string describing the source of the text.  This could be a text file path or some other identifier.</param>
            <returns>A list of tokens</returns>
        </member>
        <member name="T:PowerArgs.IfExpression">
            <summary>
            An expression that allows a portion of a document template to be rendered only if some condition is true
            </summary>
        </member>
        <member name="P:PowerArgs.IfExpression.IfExpressionToken">
            <summary>
            The token representing the conditional expression.  
            </summary>
        </member>
        <member name="P:PowerArgs.IfExpression.Body">
            <summary>
            The contents of the expression to render only if the condition is true
            </summary>
        </member>
        <member name="M:PowerArgs.IfExpression.#ctor(PowerArgs.DocumentToken,System.Collections.Generic.IEnumerable{PowerArgs.DocumentToken})">
            <summary>
            Creates a new if expression given a conditional token and a body
            </summary>
            <param name="ifExpressionToken">The token containing the conditional expression</param>
            <param name="body">The body of the document to render only if the condition evaluates to true</param>
        </member>
        <member name="M:PowerArgs.IfExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Evaluates the conditional expression against the given data context, rendering the body only if it is true.
            </summary>
            <param name="context">The data context to use when evaluating the conditional expression</param>
            <returns>The rendered body if the conditional was true, an empty string otherwise</returns>
        </member>
        <member name="T:PowerArgs.IfNotExpression">
            <summary>
            An expression that allows a portion of a document template to be rendered only if some condition is not true
            </summary>
        </member>
        <member name="M:PowerArgs.IfNotExpression.#ctor(PowerArgs.DocumentToken,System.Collections.Generic.IEnumerable{PowerArgs.DocumentToken})">
            <summary>
            Creates a new ifnot expression given a conditional token and a body
            </summary>
            <param name="ifExpressionToken">The token containing the conditional expression</param>
            <param name="body">The body of the document to render only if the condition evaluates to false</param>
        </member>
        <member name="M:PowerArgs.IfNotExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            Evaluates the conditional expression against the given data context, rendering the body only if it is false.
            </summary>
            <param name="context">The data context to use when evaluating the conditional expression</param>
            <returns>The rendered body if the conditional was false, an empty string otherwise</returns>
        </member>
        <member name="T:PowerArgs.IfExpressionProvider">
            <summary>
            An expression provider that can provide either an If expresison or an IfNot expression.
            </summary>
        </member>
        <member name="M:PowerArgs.IfExpressionProvider.#ctor(System.Boolean)">
            <summary>
            Creates a new provider, indicating whether or not this provider should provide if or ifnot expressions.
            </summary>
            <param name="not">If true, this provider will provide if expressions, otherwise it will provide ifnot expressions</param>
        </member>
        <member name="M:PowerArgs.IfExpressionProvider.CreateExpression(PowerArgs.DocumentExpressionContext)">
            <summary>
            Creates either an if or an ifnot expression, based on its configuration, using the given document info.
            </summary>
            <param name="context">The context that contains information about the document being rendered</param>
            <returns>The expression, either an if or an ifnot expression</returns>
        </member>
        <member name="T:PowerArgs.IDocumentExpression">
            <summary>
            An interface that defines a signature for evaluating an expression against a data context to render a ConsoleString.
            </summary>
        </member>
        <member name="M:PowerArgs.IDocumentExpression.Evaluate(PowerArgs.DocumentRendererContext)">
            <summary>
            The expression should use it's metadata to evaluate itself against the given data context.
            </summary>
            <param name="context">The data context</param>
            <returns>The evaluated ConsoleString.</returns>
        </member>
        <member name="T:PowerArgs.DocumentRenderException">
            <summary>
            An exception that is thrown while trying to render a templated document
            </summary>
        </member>
        <member name="T:PowerArgs.DocumentRenderException.NoTokenReason">
            <summary>
            A reason why a token was not provided when creating this exception
            </summary>
        </member>
        <member name="F:PowerArgs.DocumentRenderException.NoTokenReason.EndOfString">
            <summary>
            Indicates that there is no token specified because there was an unexpected end of string.
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentRenderException.#ctor(System.String,PowerArgs.DocumentToken)">
            <summary>
            Creates an exception given a message and the offending token
            </summary>
            <param name="msg">The exception message</param>
            <param name="offendingToken">The offending token</param>
        </member>
        <member name="M:PowerArgs.DocumentRenderException.#ctor(System.String,PowerArgs.DocumentRenderException.NoTokenReason)">
            <summary>
            Creates an exception given a message and a reason why no token was provided
            </summary>
            <param name="msg">The exception message</param>
            <param name="reason">The reason why no token was provided</param>
        </member>
        <member name="T:PowerArgs.DocumentTemplateInfo">
            <summary>
            A class that describes a document template
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentTemplateInfo.Value">
            <summary>
            The template text value
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentTemplateInfo.SourceLocation">
            <summary>
            The template's source location.  This is usually a file location, but it does not have to be.
            </summary>
        </member>
        <member name="T:PowerArgs.DocumentRenderer">
            <summary>
            A class used to render template documents.
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.#ctor">
            <summary>
            Creates a new DocumentRenderer.
            </summary>
        </member>
        <member name="P:PowerArgs.DocumentRenderer.ExpressionParser">
            <summary>
            Gets the underlying expression parser
            </summary>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.Render(PowerArgs.DocumentTemplateInfo,System.Object)">
            <summary>
            Renders a document from a template, using a plain old .NET object as a data source.
            </summary>
            <param name="template">The template to use</param>
            <param name="data">The data source to use for template replacements</param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.Render(System.String,System.Object,System.String)">
            <summary>
            Renders a document from a template, using a plain old .NET object as a data source.
            </summary>
            <param name="template">The template to use</param>
            <param name="data">The data source to use for template replacements</param>
            <param name="sourceFileLocation">The source of the template, used when reporting back errors</param>
            <returns>The rendered document</returns>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.RegisterTemplate(System.String,PowerArgs.DocumentTemplateInfo)">
            <summary>
            Register a named tamplate that can be accessed by other templates
            </summary>
            <param name="name">The unique name of the template</param>
            <param name="info">The template info</param>
        </member>
        <member name="M:PowerArgs.DocumentRenderer.UnregisterTemplate(System.String)">
            <summary>
            Unregister a named template.
            </summary>
            <param name="name">The name of the template to unregister</param>
        </member>
        <member name="T:PowerArgs.ObjectPathTokenType">
            <summary>
            An enum used to add type metadata to object path expression tokens
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.IndexerOpen">
            <summary>
            Indicates the start of an index navigation for objects like arrays, lists, and dictionaries.  '['
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.IndexerClose">
            <summary>
            Indicates the end of an index navigation for objects like arrays, lists, and dictionaries. ']'
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.NavigationElement">
            <summary>
            Indicates a property navigation for an object.
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.Identifier">
            <summary>
            Indicates a property identifier
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.Whitespace">
            <summary>
            Indicates whitespace
            </summary>
        </member>
        <member name="F:PowerArgs.ObjectPathTokenType.StringLiteral">
            <summary>
            Indicates a string literal inside of double quotes
            </summary>
        </member>
        <member name="T:PowerArgs.ObjectPathToken">
            <summary>
            A token that is a part of an object path expression string
            </summary>
        </member>
        <member name="P:PowerArgs.ObjectPathToken.TokenType">
            <summary>
            Gets the type of token
            </summary>
        </member>
        <member name="M:PowerArgs.ObjectPathToken.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an object path token
            </summary>
            <param name="initialValue">The initial value of the token</param>
            <param name="startIndex">The start index of the token in the source string</param>
            <param name="line">The line number that this token is on</param>
            <param name="col">The column within the line that this token is on</param>
        </member>
        <member name="M:PowerArgs.ObjectPathToken.TokenFactoryImpl(PowerArgs.Token,System.Collections.Generic.List{PowerArgs.ObjectPathToken})">
            <summary>
            A method that can determine which type of token the given value is
            </summary>
            <param name="token">The token to classify</param>
            <param name="previous">Previously classified tokens in the source string</param>
            <returns>The classified token</returns>
        </member>
        <member name="T:PowerArgs.ObjectPathExpression">
            <summary>
            An object that represents navigation into an object properties or indexed elements
            </summary>
        </member>
        <member name="P:PowerArgs.ObjectPathExpression.Elements">
            <summary>
            The path elements for this expression
            </summary>
        </member>
        <member name="M:PowerArgs.ObjectPathExpression.#ctor(System.Collections.Generic.IEnumerable{PowerArgs.IObjectPathElement})">
            <summary>
            Create a path expression given a collection of path elements
            </summary>
            <param name="elements">The path elements</param>
        </member>
        <member name="M:PowerArgs.ObjectPathExpression.Parse(System.String)">
            <summary>
            Parses an object path expression from a string.
            </summary>
            <param name="expression">The expression text to parse</param>
            <returns>The parsed expression</returns>
        </member>
        <member name="M:PowerArgs.ObjectPathExpression.Evaluate(System.Object)">
            <summary>
            Evaluates the expression and returns the value
            </summary>
            <param name="root">the object to evaluate against</param>
            <returns>The result of the evaluation</returns>
        </member>
        <member name="M:PowerArgs.ObjectPathExpression.EvaluateAndTrace(System.Object)">
            <summary>
            Evaluates the expression, returning the object that corresponds to each element in the path.
            </summary>
            <param name="root">the object to evaluate against</param>
            <returns>A list of object where each object corresponds to an element in the path</returns>
        </member>
        <member name="T:PowerArgs.IObjectPathElement">
            <summary>
            An object that represents a path element
            </summary>
        </member>
        <member name="T:PowerArgs.PropertyPathElement">
            <summary>
            A path element that represents an object's property
            </summary>
        </member>
        <member name="P:PowerArgs.PropertyPathElement.PropertyName">
            <summary>
            Gets the name of the property
            </summary>
        </member>
        <member name="M:PowerArgs.PropertyPathElement.#ctor(System.String)">
            <summary>
            Creates a property path element given a property name
            </summary>
            <param name="propertyName">the name of the property</param>
        </member>
        <member name="M:PowerArgs.PropertyPathElement.ToString">
            <summary>
            Returns the property name
            </summary>
            <returns>the property name</returns>
        </member>
        <member name="T:PowerArgs.IndexerPathElement">
            <summary>
            A path element that represents an index navigation
            </summary>
        </member>
        <member name="P:PowerArgs.IndexerPathElement.Index">
            <summary>
            The indexer value, either a literal string or an integer
            </summary>
        </member>
        <member name="M:PowerArgs.IndexerPathElement.#ctor(System.Object)">
            <summary>
            Creates an indexer element given an indexer value
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:PowerArgs.IndexerPathElement.FindMatchingProperty(System.Object)">
            <summary>
            Finds the matching property info that represents an indexer property (do not use for strings or arrays).
            </summary>
            <param name="target">The object to search</param>
            <returns>The matching property</returns>
        </member>
        <member name="M:PowerArgs.IndexerPathElement.ToString">
            <summary>
            returns '[' + the index value + ']'
            </summary>
            <returns>'[' + the index value + ']'</returns>
        </member>
        <member name="T:PowerArgs.TokenizerException">
            <summary>
            An exception that will be thrown if there was an error while tokenizing a string.
            </summary>
        </member>
        <member name="M:PowerArgs.TokenizerException.#ctor(System.String)">
            <summary>
            Creates a new tokenizer exception given a message
            </summary>
            <param name="message">The exception message</param>
        </member>
        <member name="T:PowerArgs.Token">
            <summary>
            A base token class that represents a substring from a document.  The location in the source
            document is tracked along with the substring so that code that processes the token can indicate
            where problems are to the user who supplied the document if needed.
            </summary>
        </member>
        <member name="P:PowerArgs.Token.Value">
            <summary>
            Gets the value of the token
            </summary>
        </member>
        <member name="P:PowerArgs.Token.StartIndex">
            <summary>
            Gets the zero based start index of this token in the document
            </summary>
        </member>
        <member name="P:PowerArgs.Token.SourceFileLocation">
            <summary>
            Gets a string that represents the source file of this document.  It does not need to be a file name, but it usually is.
            </summary>
        </member>
        <member name="P:PowerArgs.Token.EndIndex">
            <summary>
            Gets the end index of the token in the document
            </summary>
        </member>
        <member name="P:PowerArgs.Token.Line">
            <summary>
            Gets the 1 based line number of the token in the document
            </summary>
        </member>
        <member name="P:PowerArgs.Token.Column">
            <summary>
            Gets the 1 based index of the token within it's line
            </summary>
        </member>
        <member name="P:PowerArgs.Token.Position">
            <summary>
            Gets a string that represents the position of this token in the source document. 
            </summary>
        </member>
        <member name="M:PowerArgs.Token.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a token given an initial value, a start index, a line number, and a column number
            </summary>
            <param name="initialValue">The initial value of a token.  You can append to the token later</param>
            <param name="startIndex">the zero based start index of this token in the document</param>
            <param name="line">the 1 based line number of the token in the document</param>
            <param name="col">the 1 based index of the token within it's line</param>
        </member>
        <member name="M:PowerArgs.Token.ToString">
            <summary>
            Gets a string representation of the token, along with position info
            </summary>
            <returns>a string representation of the token, along with position info</returns>
        </member>
        <member name="M:PowerArgs.Token.As``1">
            <summary>
            Creates a new instance of the strongly typed token and copies all of the base token's properties to the new value
            </summary>
            <typeparam name="T">The type of the derived token.</typeparam>
            <returns>The strongly typed token</returns>
        </member>
        <member name="T:PowerArgs.WhitespaceBehavior">
            <summary>
            An enum describing the different ways the tokenizer can handle whitespace
            </summary>
        </member>
        <member name="F:PowerArgs.WhitespaceBehavior.DelimitAndInclude">
            <summary>
            Treats whitespace as a delimiter and includes the whitespace tokens in the output list of tokens
            </summary>
        </member>
        <member name="F:PowerArgs.WhitespaceBehavior.DelimitAndExclude">
            <summary>
            Treats whitespace as a delimiter, but excludes the whitespace tokens from the output list of tokens
            </summary>
        </member>
        <member name="F:PowerArgs.WhitespaceBehavior.Include">
            <summary>
            Includes whitespace in the output and does not treat it as a delimiter
            </summary>
        </member>
        <member name="T:PowerArgs.DoubleQuoteBehavior">
            <summary>
            An enum describing the different ways the tokenizer can handle double quotes
            </summary>
        </member>
        <member name="F:PowerArgs.DoubleQuoteBehavior.NoSpecialHandling">
            <summary>
            No special handling.  Double quotes will be treated like any normal character.  You can include the double quote in the delimiters list.
            </summary>
        </member>
        <member name="F:PowerArgs.DoubleQuoteBehavior.IncludeQuotedTokensAsStringLiterals">
            <summary>
            Treat values within double quotes as string literals.
            </summary>
        </member>
        <member name="T:PowerArgs.Tokenizer`1">
            <summary>
            A general purpose string tokenizer
            </summary>
            <typeparam name="T">The type of tokens that this tokenizer should output</typeparam>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.Delimiters">
            <summary>
            strings to treat as delimiters.  Delimiters with longer lengths will take preference over
            those with shorter lengths.  For example if you add delimiters '{{' and '{' and the document
            contains '{{Hello' then you'll get 2 tokens, first '{{', then 'hello'
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.TokenFactory">
            <summary>
            A function that given a plain token can transform it into the strongly typed token
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.WhitespaceBehavior">
            <summary>
            Gets or sets the option that describes how whitespace should be treated.
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.DoubleQuoteBehavior">
            <summary>
            Gets or sets the option that describes how double quotes should be treated.
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.EscapeSequenceIndicator">
            <summary>
            An escape sequence identifier.  By default it is '\'
            </summary>
        </member>
        <member name="P:PowerArgs.Tokenizer`1.SourceFileLocation">
            <summary>
            A string that describes the source location for the given document
            </summary>
        </member>
        <member name="M:PowerArgs.Tokenizer`1.#ctor">
            <summary>
            Creates a new tokenizer
            </summary>
        </member>
        <member name="M:PowerArgs.Tokenizer`1.Tokenize(System.String)">
            <summary>
            Tokenizes the given string into a list of tokens
            </summary>
            <param name="input">The string to tokenize</param>
            <returns>The list of tokens</returns>
        </member>
        <member name="T:PowerArgs.ArgHiddenFromUsage">
            <summary>
            Use this attribute to hide an argument from the usage output.  Users will still be able to provide
            the argument, but it will be undocumented.  This is useful if you want to invlude some secret commands
            or diagnostic commands.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgHiddenFromUsage.BeforeGenerateUsage(PowerArgs.ArgumentUsageInfo)">
            <summary>
            Sets the ignore flag on the info context so the usage generator skips this argument.
            </summary>
            <param name="info">The info about the argument we're hiding</param>
        </member>
        <member name="T:PowerArgs.SingleActionHook">
            <summary>
            Creates a hook from an action
            </summary>
        </member>
        <member name="P:PowerArgs.SingleActionHook.HookImpl">
            <summary>
            Gets the hook implementation that was passed to the constructor
            </summary>
        </member>
        <member name="P:PowerArgs.SingleActionHook.HookId">
            <summary>
            Gets the Id or name of the hook
            </summary>
        </member>
        <member name="M:PowerArgs.SingleActionHook.#ctor(System.String,System.Int32,System.Action{PowerArgs.ArgHook.HookContext})">
            <summary>
            Creates a new hook with the given name, priority, and implementation
            </summary>
            <param name="hookId">The id or name of the hook</param>
            <param name="priority">The priority of the hook (higher numbers execute first)</param>
            <param name="hookImpl">The hook implementation</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.AfterCancel(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.AfterInvoke(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.AfterPopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.AfterPopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.BeforeInvoke(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.BeforePopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.BeforePrepareUsage(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="M:PowerArgs.SingleActionHook.BeforeValidateDefinition(PowerArgs.ArgHook.HookContext)">
            <summary>
            Calls the underlying hook if it was specified in the constructor
            </summary>
            <param name="context">The processing context</param>
        </member>
        <member name="T:PowerArgs.ArgHook">
            <summary>
            An abstract class that you can implement if you want to hook into various parts of the
            parsing pipeline.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgHook.HookContext">
            <summary>
            Context that is passed to your hook.  Different parts of the context will be available
            depending on which part of the pipeline you're hooking into.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.Current">
            <summary>
            Gets the context for the current parse operation happening on the current thread or
            null if no parse is happening on the current thread.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.Property">
            <summary>
            The current property being operating on.  This is not available during BeforePopulateProperties or
            AfterPopulateProperties.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.CurrentArgument">
            <summary>
            The current argument being operating on. 
            AfterPopulateProperties.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.SpecifiedAction">
            <summary>
            Gets the action that was specified on the command line or null if no action was specified or if the definition exposes no actions.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgHook.HookContext.CmdLineArgs">
            <summary>
            The command line arguments that were passed to the Args class.  This is always available and you
            can modify it in the BeforeParse hook at your own risk.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgHook.HookContext.ArgumentValue">
            <summary>
            The string value that was specified for the current argument.  This will align with the value of ArgHook.CurrentArgument.
            
            This is not available during BeforePopulateProperties or
            AfterPopulateProperties.
            
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.Args">
            <summary>
            This is the instance of your argument class.  The amount that it is populated will depend on how far along in the pipeline
            the parser is.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.Definition">
            <summary>
            The definition that's being used throughout the parsing process
            </summary>
        </member>
        <member name="F:PowerArgs.ArgHook.HookContext.RevivedProperty">
            <summary>
            This is the value of the current property after it has been converted into its proper .NET type.  It is only available
            to the AfterPopulateProperty hook.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.HookContext.ParserData">
            <summary>
            The raw parser data.  This is not available to the BeforeParse hook.  It may be useful for you to look at, but you should rarely have to change the values.  
            Modify the content of this at your own risk.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.GetProperty``1(System.String)">
            <summary>
            Get a value from the context's property bag.
            </summary>
            <typeparam name="T">The type of value you are expecting</typeparam>
            <param name="key">The key for the property you want to get</param>
            <returns>The value or default(T) if no value was found.</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.SetProperty``1(System.String,``0)">
            <summary>
            Set a value in the context's property bag.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key">The key for the property you want to set</param>
            <param name="value">The value of the property to set</param>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.HasProperty(System.String)">
            <summary>
            Returns true if the context has a value for the given property.
            </summary>
            <param name="key">The key to check</param>
            <returns>true if the context has a value for the given property, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.ClearProperty(System.String)">
            <summary>
            Clear a value in the context's property bag.
            </summary>
            <param name="key">The key for the property you want to clear.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.HookContext.CancelAllProcessing">
            <summary>
            Stops all argument processing, hooks, and action invocation as soon as is feasable.  You
            can implement an ArgHook that receives an event when this is called.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforeValidateDefinitionPriority">
            <summary>
            The priority of the BeforeValidateDefinition hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforePrepareUsagePriority">
            <summary>
            The priority of the BeforePrepareUsage hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforeParsePriority">
            <summary>
            The priority of the BeforeParse hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforePopulatePropertiesPriority">
            <summary>
            The priority of the BeforePopulateProperties hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforePopulatePropertyPriority">
            <summary>
            The priority of the BeforePopulateProperty hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.AfterPopulatePropertyPriority">
            <summary>
            The priority of the AfterPopulateProperty hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.AfterPopulatePropertiesPriority">
            <summary>
            The priority of the AfterPopulateProperties hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.BeforeInvokePriority">
            <summary>
            The priority of the BeforeInvoke hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.AfterInvokePriority">
            <summary>
            The priority of the AfterInvoke hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgHook.AfterCancelPriority">
            <summary>
            The priority of the AfterCancel hook.  Higher numbers execute first.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforeValidateDefinition(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before the definition is validated for structural issues
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateBeforeValidateDefinitionHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforePrepareUsage(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before the template based usage system prepares the usage documentation
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateBeforePrepareUsageHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before the parser ever looks at the command line.  You can do some preprocessing of the 
            raw string arguments here.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateBeforeParseHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforePopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before the arguments defined in a class are populated.  For actions (or sub commands) this hook will
            get called once for the main class and once for the specified action.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateBeforePopulatePropertiesHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called before an argument is transformed from a string into a proper type and validated.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateBeforePopulatePropertyHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.AfterPopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called after an argument is transformed from a string into a proper type and validated.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateAfterPopulatePropertyHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.AfterPopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called after the arguments defined in a class are populated.  For actions (or sub commands) this hook will
            get called once for the main class and once for the specified action.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateAfterPopulatePropertiesHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.BeforeInvoke(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called after parsing is complete, but before any Action or Main method is invoked.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateBeforeInvokeHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.AfterInvoke(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called after any Action or Main method is invoked.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateAfterInvokeHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="M:PowerArgs.ArgHook.AfterCancel(PowerArgs.ArgHook.HookContext)">
            <summary>
            This hook is called if CancelAllProcessing() is called on a HookContext object.
            </summary>
            <param name="context">An object that has useful context.  See the documentation of each property for information about when those properties are populated.</param>
        </member>
        <member name="M:PowerArgs.ArgHook.CreateAfterCancelHook(System.Action{PowerArgs.ArgHook.HookContext},System.Int32)">
            <summary>
            Creates a hook that targets the corresponding hook method given an implementation and a priority
            </summary>
            <param name="action">The hook implementation</param>
            <param name="priority">The hook priority (higher executes first)</param>
            <returns>The hook</returns>
        </member>
        <member name="T:PowerArgs.DefaultValueAttribute">
            <summary>
            Use this attribute to set the default value for a parameter.  Note that this only
            works for simple types since only compile time constants can be passed to an attribute.
            </summary>
        </member>
        <member name="P:PowerArgs.DefaultValueAttribute.Value">
            <summary>
            The default value that was specified on the attribute.  Note that the value will get
            converted to a string and then fed into the parser to be revived.
            </summary>
        </member>
        <member name="M:PowerArgs.DefaultValueAttribute.#ctor(System.Object)">
            <summary>
            Creates a new DefaultValueAttribute with the given value.  Note that the value will get
            converted to a string and then fed into the parser to be revived.
            </summary>
            <param name="value">The default value for the property</param>
        </member>
        <member name="M:PowerArgs.DefaultValueAttribute.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            Before the property is revived and validated, if the user didn't specify a value, 
            then substitue the default value.
            
            </summary>
            <param name="Context"></param>
        </member>
        <member name="T:PowerArgs.ArgDefaultValueAttribute">
            <summary>
            Use this attribute to set the default value for a parameter.  Note that this only
            works for simple types since only compile time constants can be passed to an attribute.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgDefaultValueAttribute.#ctor(System.Object)">
            <summary>
            Creates a new ArgDefaultValueAttribute with the given value.  Note that the value will get
            converted to a string and then fed into the parser to be revived.
            </summary>
            <param name="value">The default value for the property</param>
        </member>
        <member name="T:PowerArgs.HelpHook">
            <summary>
            A hook that lets you turn a boolean property into a command line switch that short circuits processing and displays help.
            </summary>
        </member>
        <member name="P:PowerArgs.HelpHook.EXEName">
            <summary>
            Optional.  The name of the EXE that is displayed by the help.  By default it will use the entry assembly exe name.
            </summary>
        </member>
        <member name="P:PowerArgs.HelpHook.ShowTypeColumn">
            <summary>
            Optionally show the TYPE column in the auto generated usage.  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.HelpHook.ShowPositionColumn">
            <summary>
            Optionally show the POSITION column in the auto generated usage.  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.HelpHook.ShowPossibleValues">
            <summary>
            Set to true to list possible values (usually for enums).  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.HelpHook.UsageTemplateProviderType">
            <summary>
            A type that should implement IUsageTemplateProvider.  When specified the help hook will use the GenerateUsageFromTemplate function rather than the obsolete GenerateStyledUsage function.
            </summary>
        </member>
        <member name="P:PowerArgs.HelpHook.WriteHelp">
            <summary>
            If true (which it is by default) the hook will write the help after the target property is populated.  If false, processing will still stop, but
            the help will not be written (yoy will have to do it yourself).
            </summary>
        </member>
        <member name="E:PowerArgs.HelpHook.UsageWritten">
            <summary>
            An event that fires when the hook writes usage to the console
            </summary>
        </member>
        <member name="M:PowerArgs.HelpHook.#ctor">
            <summary>
            Creates a new help hook instance
            </summary>
        </member>
        <member name="M:PowerArgs.HelpHook.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            Makes sure the target is a boolean
            </summary>
            <param name="context">Context passed by the parser</param>
        </member>
        <member name="M:PowerArgs.HelpHook.AfterPopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            This gets called after the target property is populated.  It cancels processing.
            </summary>
            <param name="context">Context passed by the parser</param>
        </member>
        <member name="M:PowerArgs.HelpHook.AfterCancel(PowerArgs.ArgHook.HookContext)">
            <summary>
            Writes the help as long as WriteHelp is true
            </summary>
            <param name="context">Context passed by the parser</param>
        </member>
        <member name="T:PowerArgs.StickyArg">
            <summary>
            A useful arg hook that will store the last used value for an argument and repeat it the next time.
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArg.#ctor">
            <summary>
            Marks a property as a sticky arg.  Use the default location to store sticky arguments (AppData/Roaming/PowerArgs/EXE_NAME.txt)
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArg.#ctor(System.String)">
            <summary>
            Marks a property as a sticky arg.  Use the provided location to store sticky arguments (AppData/Roaming/PowerArgs/EXE_NAME.txt)
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArg.BeforePopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            If the user didn't specify a value on the command line then the StickyArg will try to load the last used
            value.
            </summary>
            <param name="Context">Used to see if the property was specified.</param>
        </member>
        <member name="M:PowerArgs.StickyArg.AfterPopulateProperty(PowerArgs.ArgHook.HookContext)">
            <summary>
            If the given property has a non null value then that value is persisted for the next use.
            </summary>
            <param name="Context">Used to see if the property was specified.</param>
        </member>
        <member name="M:PowerArgs.StickyArg.GetStickyArg(System.String)">
            <summary>
            Gets the value of the given sticky arg
            </summary>
            <param name="name">the argument key</param>
            <returns>the sticky value or null if there is not one</returns>
        </member>
        <member name="M:PowerArgs.StickyArg.SetStickyArg(System.String,System.String)">
            <summary>
            Sets the value of a sticky arg
            </summary>
            <param name="name">The identifier of the arg</param>
            <param name="value">the sticky value</param>
        </member>
        <member name="T:PowerArgs.IStickyArgPersistenceProvider">
            <summary>
            An interface used to implement custom saving and loading of persistent (sticky) args.
            </summary>
        </member>
        <member name="M:PowerArgs.IStickyArgPersistenceProvider.Save(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            This method is called when it is time to save the sticky args.
            </summary>
            <param name="stickyArgs">The names and values of the arguments to save.</param>
            <param name="pathInfo">The string that was passed to the StickyArg attribue (usually a file path).</param>
        </member>
        <member name="M:PowerArgs.IStickyArgPersistenceProvider.Load(System.String)">
            <summary>
            This method is called when it is time to load the sticky args.
            </summary>
            <param name="pathInfo">The string that was passed to the StickyArg attribue (usually a file path).</param>
            <returns>The loaded sticky args.</returns>
        </member>
        <member name="T:PowerArgs.StickyArgPersistence">
            <summary>
            An attribute you can put on a type in order to override how StickyArg properties are saved and loaded.
            </summary>
        </member>
        <member name="P:PowerArgs.StickyArgPersistence.PersistenceProvider">
            <summary>
            Gets the provider that will be used to save and load sticky args.
            </summary>
        </member>
        <member name="M:PowerArgs.StickyArgPersistence.#ctor(System.Type)">
            <summary>
            Creates a new StickyArgPersistence attribute given the type of the persistence provider.
            </summary>
            <param name="persistenceProviderType">The type that implements IStickyArgPersistenceProvider and defines a default constructor.</param>
        </member>
        <member name="T:PowerArgs.ArgActionMethod">
            <summary>
            Use this attribute to annotate methods that represent your program's actions.  
            </summary>
        </member>
        <member name="T:PowerArgs.ArgActionType">
            <summary>
            Use this attribute if your action implementation methods are defined in a type other than the 
            type being passed to Args.ParseAction() or Args.InvokeAction().  You can add multiple attributes
            of this type if you want to combine actions from multiple classes.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgActionType.ActionType">
            <summary>
            The type that implements your action methods.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgActionType.#ctor(System.Type)">
            <summary>
            Creates a new ArgActionType attribute given the type that contains the action implementation.
            </summary>
            <param name="t">The type that implements your action methods.</param>
        </member>
        <member name="T:PowerArgs.ArgActions">
            <summary>
            An attribute you can put on classes that contain arg action methods that can be imported into a program
            that uses an [ArgActionResolver] attribute.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgActionResolver">
            <summary>
            An attribute you can put on a program's main scaffold class in order to import external types that contain
            action methods.  By default, this resolver will search the program's entry assembly for types that contain the
            [ArgActions] attribute.  You can derive from this class and override the ResolveActionTypes method if you want to
            perform custom resolution of actions.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgActionResolver.ResolveActionTypes">
            <summary>
            Searches the program's entry assembly for types that contain an [ArgActions] attribute and returns those
            types so that PowerArgs can import them into the running program.  This method is marked as virtual so that
            classes that derive from ArgActionResolver can implement their own resolution strategy.
            </summary>
            <returns>matching types</returns>
        </member>
        <member name="T:PowerArgs.NonInteractiveIndicator">
            <summary>
            An attribute that can be specified on a boolean argument to indicate a non interactive session.  
            When used, it sets IsNonInteractive on the current definition.
            </summary>
        </member>
        <member name="M:PowerArgs.NonInteractiveIndicator.#ctor">
            <summary>
            Creates a new NonInteractiveIndicator attribute
            </summary>
        </member>
        <member name="M:PowerArgs.NonInteractiveIndicator.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            If the current argument is a boolean and it is specified on the command line then
            this hook sets the IsNonInteractive flag on the current argument definition.
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:PowerArgs.ArgDescription">
            <summary>
            Use this attribute to describe your argument property.  This will show up in the auto generated
            usage documentation.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgDescription.Description">
            <summary>
            A brief description of your argument property.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgDescription.#ctor(System.String)">
            <summary>
            Creates a new ArgDescription attribute.
            </summary>
            <param name="description">A brief description of your argument property.</param>
        </member>
        <member name="T:PowerArgs.ArgExample">
            <summary>
            Use this attribute to provide an example of how to use your program.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExample.HasTitle">
            <summary>
            Returns true if this example has a title, false otherwwise
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExample.Title">
            <summary>
            An optional title for this example
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExample.Example">
            <summary>
            The example command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExample.Description">
            <summary>
            A brief description of what this example does.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExample.#ctor(System.String,System.String)">
            <summary>
            Creates a new ArgExample class
            </summary>
            <param name="example">The example command line.</param>
            <param name="description">A brief description of what this example does.</param>
        </member>
        <member name="T:PowerArgs.ArgExceptionPolicy">
            <summary>
            Enum used to specify how user errors (ArgExceptions) should be handled by the parser.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgExceptionPolicy.DontHandleExceptions">
            <summary>
            The default, PowerArgs will throw these exceptions for your program to handle.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgExceptionPolicy.StandardExceptionHandling">
            <summary>
            PowerArgs will print the user friendly error message as well as the auto-generated usage documentation
            for the program.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgExceptionBehavior">
            <summary>
            Use this attrbiute to opt into standard error handling of user input errors.  
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.Policy">
            <summary>
            The policy to use, defaults to DontHandleExceptions.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.ShowTypeColumn">
            <summary>
            Optionally show the TYPE column in the auto generated usage.  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.ShowPositionColumn">
            <summary>
            Optionally show the POSITION column in the auto generated usage.  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.ShowPossibleValues">
            <summary>
            Set to true to list possible values (usually for enums).  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.ExeName">
            <summary>
            Optionally override the ExeName.  You need to do this in unit tests.  In a real console app the
            value will be detected automatically if you leave this as null.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.UsageTemplateFile">
            <summary>
            The usage template to use to display usage information.  You can leave this null if you want to use the default template.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgExceptionBehavior.UsageTemplateProviderType">
            <summary>
            A type that should implement IUsageTemplateProvider.  When specified the help hook will use the GenerateUsageFromTemplate function rather than the obsolete GenerateStyledUsage function.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExceptionBehavior.#ctor(PowerArgs.ArgExceptionPolicy)">
            <summary>
            Creates a new ArgExceptionBehavior attributes with the given policy.
            </summary>
            <param name="policy">The policy to use, defaults to DontHandleExceptions.</param>
        </member>
        <member name="T:PowerArgs.ArgIgnoreAttribute">
            <summary>
            Use this attribute if you want PowerArgs to ignore a property completely.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgIgnoreCase">
            <summary>
            Use this argument on your class, property, or action method to enforce case sensitivity.  By default,
            case is ignored.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgIgnoreCase.IgnoreCase">
            <summary>
            Flag to set whether or not case is ignored.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgIgnoreCase.#ctor(System.Boolean)">
            <summary>
            Create a new ArgIgnoreCase attribute.
            </summary>
            <param name="ignore">Whether or not to ignore case</param>
        </member>
        <member name="T:PowerArgs.ArgEnforceCase">
            <summary>
            Use this argument on your class or property to enforce case sensitivity.  By default,
            case is ignored.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgEnforceCase.#ctor">
            <summary>
            Create a new ArgEnforceCase attribute.
            </summary>
        </member>
        <member name="T:PowerArgs.IArgMetadata">
            <summary>
            Any attribute that's purpose is to add information about a command line arguments definiton should
            derive from this type.  
            </summary>
        </member>
        <member name="T:PowerArgs.ICommandLineArgumentMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineArguments
            </summary>
        </member>
        <member name="T:PowerArgs.ICommandLineActionMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineActions
            </summary>
        </member>
        <member name="T:PowerArgs.ICommandLineArgumentsDefinitionMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineArgumentsDefinition instances
            </summary>
        </member>
        <member name="T:PowerArgs.IArgumentOrActionMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineArguments or CommandLineActions
            </summary>
        </member>
        <member name="T:PowerArgs.IGlobalArgMetadata">
            <summary>
            Represents IArgMetadata that is valid for CommandLineArguments, CommandLineActions, and CommandLineArgumentsDefinition instances
            </summary>
        </member>
        <member name="T:PowerArgs.ArgPosition">
            <summary>
            Use this attribute if you want users to be able to specify an argument without specifying the name, 
            but rather by it's position on the command line.  All positioned arguments must come before any named arguments.
            Zero '0' represents the first position.  If you are using the Action framework then subcommands must start at
            position 1.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgPosition.Position">
            <summary>
            The expected position of this argument
            </summary>
        </member>
        <member name="M:PowerArgs.ArgPosition.#ctor(System.Int32)">
            <summary>
            Creates a new ArgPositionAttribute
            </summary>
            <param name="pos">The expected position of this argument</param>
        </member>
        <member name="T:PowerArgs.ArgReviverAttribute">
            <summary>
            The attribute used when you want to create an arg reviver. You should put this on public static methods 
            that take 2 string parameters (the first represents the name of the property, the second represents the string value
            and the return type is the type that you are reviving (or converting) the string into.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgShortcutPolicy">
            <summary>
            An enum to represent argument shortcut policies
            </summary>
        </member>
        <member name="F:PowerArgs.ArgShortcutPolicy.Default">
            <summary>
            No special behavior.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgShortcutPolicy.NoShortcut">
            <summary>
            Pass this value to the ArgShortcut attribute's constructor to indicate that the given property
            does not support a shortcut.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgShortcutPolicy.ShortcutsOnly">
            <summary>
            This indicates that the .NET property named should not be used as an indicator.  Instead,
            only the values in the other ArgShortcut attributes should be used.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgShortcut">
            <summary>
            Use this attribute to override the shortcut that PowerArgs automatically assigns to each property.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgShortcut.Shortcut">
            <summary>
            The shortcut for the given property
            </summary>
        </member>
        <member name="P:PowerArgs.ArgShortcut.Policy">
            <summary>
            Get the ShortcutPolicy for this attribute.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgShortcut.#ctor(System.String)">
            <summary>
            Creates a new ArgShortcut attribute with a specified value.
            </summary>
            <param name="shortcut">The value of the new shortcut.</param>
        </member>
        <member name="M:PowerArgs.ArgShortcut.#ctor(PowerArgs.ArgShortcutPolicy)">
            <summary>
            Creates a new ArgShortcut using the given policy
            </summary>
            <param name="policy"></param>
        </member>
        <member name="T:PowerArgs.ArgLongForm">
            <summary>
            An attribute used to define long form aliases for argument
            names.  For example, --log-level instead of -log.
            It also supports an alternate syntax for providing the values.
            For example: --log-level=error instead of -log error or /log:error.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgLongForm.#ctor(System.String)">
            <summary>
            Creates a new instance of an ArgLongForm attribute given the shortcut value.
            </summary>
            <param name="value">The shortcut value</param>
        </member>
        <member name="T:PowerArgs.ArgStyle">
            <summary>
            Obsolete, both the -name value and /name:value styles are supported automatically.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgStyle.PowerShell">
            <summary>
            Obsolete, both the -name value and /name:value styles are supported automatically.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgStyle.SlashColon">
            <summary>
            Obsolete, both the -name value and /name:value styles are supported automatically.
            </summary>
        </member>
        <member name="T:PowerArgs.ArgStyleAttribute">
            <summary>
            Obsolete - Don't use this.  Both the -name value and /name:value styles are now both supported automatically.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgStyleAttribute.Style">
            <summary>
            Obsolete - Don't use this.  Both the -name value and /name:value styles are now both supported automatically.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgStyleAttribute.#ctor(PowerArgs.ArgStyle)">
            <summary>
            Obsolete - Don't use this.  Both the -name value and /name:value styles are now both supported automatically.
            </summary>
            <param name="style">obsolete</param>
        </member>
        <member name="T:PowerArgs.OmitFromUsageDocs">
            <summary>
            An attribute that, when placed on a property or action method, makes sure that property/action does not appear
            in the output created by the ArgUsage class (the class that auto generates usage documentation).
            </summary>
        </member>
        <member name="M:PowerArgs.OmitFromUsageDocs.BeforeGenerateUsage(PowerArgs.ArgumentUsageInfo)">
            <summary>
            sets the ignroe flag on the info object
            </summary>
            <param name="info">the context used to modify the usage documentation</param>
        </member>
        <member name="T:PowerArgs.CommandLineAction">
            <summary>
            A class that represents command line actions that users can specify on the command line.  This is useful for programs like git
            where users first specify an action like 'push' and then the remaining arguments are either global or specific to 'push'.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Aliases">
            <summary>
            The values that the user can specify on the command line to specify this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Arguments">
            <summary>
            The action specific arguments that are applicable to the end user should they specify this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.UsageSummary">
            <summary>
            Creates a usage summary string that is specific to this action and accounts for positional argument, etc.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.UsageSummaryHTMLEncoded">
            <summary>
            Creates a usage summary string that is specific to this action and accounts for positional argument, etc. where the
            brackets are html encoded
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Description">
            <summary>
            The description that will be shown in the auto generated usage.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Source">
            <summary>
            The method or property that was used to define this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.IsSpecifiedAction">
            <summary>
            This will be set by the parser if the parse was successful and this was the action the user specified.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.IgnoreCase">
            <summary>
            Indicates whether or not the parser should ignore case when matching a user string with this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.DefaultAlias">
            <summary>
            The first alias or null if there are no aliases.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Metadata">
            <summary>
            The list of metadata that can be used to inject behavior into the action
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.ActionMethod">
            <summary>
            The implementation of the action that can be invoked by the parser if the user specifies this action.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.HasExamples">
            <summary>
            Returns true if there is at least 1 ArgExample metadata on this action
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.HasArguments">
            <summary>
            Returns true if this action has at least 1 action specific argument
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineAction.Examples">
            <summary>
            Examples that show users how to use this action.
            </summary>
        </member>
        <member name="M:PowerArgs.CommandLineAction.#ctor(System.Action{PowerArgs.CommandLineArgumentsDefinition})">
            <summary>
            Creates a new command line action given an implementation.
            </summary>
            <param name="actionHandler">The implementation of the action.</param>
        </member>
        <member name="M:PowerArgs.CommandLineAction.ToString">
            <summary>
            Gets a string representation of this action.
            </summary>
            <returns>a string representation of this action</returns>
        </member>
        <member name="M:PowerArgs.CommandLineAction.Equals(System.Object)">
            <summary>
            Determines if 2 actions are the same based on their source.  
            </summary>
            <param name="obj">The other action</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.CommandLineAction.FindMatchingArgument(System.String,System.Boolean)">
            <summary>
            Finds the first CommandLineArgument that matches the given key.
            </summary>
            <param name="key">The key as if it was typed in on the command line.  This can also be an alias. </param>
            <param name="throwIfMoreThanOneMatch">If set to true then this method will throw and InvalidArgDeginitionException if more than 1 match is found</param>
            <returns>The first argument that matches the key.</returns>
        </member>
        <member name="T:PowerArgs.CommandLineArgument">
            <summary>
            Instances of this class represent a single command line argument that users can specify on the command line.
            Supported syntaxes include:
                -argumentName argumentValue
                /argumentName:argumentValue
                -argumentName                   - If the argument is a boolean it will be true in this case.
                --argumentName=argumentValue    - Only works if you have added an alias that starts with --.
                argumentValue                   - Only works if this argument defines the Position property as >= 0
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Aliases">
            <summary>
            The values that can be used as specifiers for this argument on the command line
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Metadata">
            <summary>
            Metadata that has been injected into this Argument
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.FriendlyTypeName">
            <summary>
            Gets a friendly type name for this argument.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.MustBeRevivable">
            <summary>
            Gets or sets a flag indicating that this argument must be revivable from a string.  If false, the argument can only be populated
            programatically and if specified on the command line without a reviver the program will throw an InvalidArgDefinitionException.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.ArgumentType">
            <summary>
            The CLR type of this argument.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.IgnoreCase">
            <summary>
            Specifies whether or not the parser should ignore case when trying to find a match for this argument on the command line.  Defaults to true.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.IsEnum">
            <summary>
            Returns true if the argument is an enum or a nullable where the value type is an enum
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.OmitFromUsage">
            <summary>
            Specifies whether this argument should be omitted from usage documentation
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.IncludeInUsage">
            <summary>
            True if this argument should be included in usage documentation
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Position">
            <summary>
            If this is a positional argument then set this value >= 0 and users can specify a value without specifying an argument alias.  Defaults to -1.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.HasDefaultValue">
            <summary>
            Returns true if a default value has been explicitly registered for this argument
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.DefaultValue">
            <summary>
            The default value for this argument in the event it is optional and the user did not specify it.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.EnumValuesAndDescriptions">
            <summary>
            Only works if the ArgumentType is an enum or a nullable where the value type is an enum.  Returns a list where each element is a string containing an
            enum value and optionally its description.  Each enum value is represented in the list.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Description">
            <summary>
            The description for this argument that appears in the auto generated usage.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.IsRequired">
            <summary>
            Gets or sets whether or not this argument is required.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.Source">
            <summary>
            If this argument was inferred from a type then the source is either a PropertyInfo or a ParameterInfo.  If this argument
            was created manually then this value will be null.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.RevivedValue">
            <summary>
            This property will contain the parsed value of the command line argument if parsing completed successfully.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.RevivedValueOverride">
            <summary>
            When set, the given value will be used to revive this argument rather than performing validation and revival.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgument.DefaultAlias">
            <summary>
            The first alias of this argument or null if no aliases are defined.
            </summary>
        </member>
        <member name="M:PowerArgs.CommandLineArgument.#ctor(System.Type,System.String,System.Boolean)">
            <summary>
            Creates a command line argument of the given type and sets the first default alias.
            </summary>
            <param name="t">The CLR type of the argument</param>
            <param name="defaultAlias">The default name that users will use to specify this argument</param>
            <param name="ignoreCase">If true, the parser will match this argument even if the specifier doesn't match case.  True by default.</param>
        </member>
        <member name="M:PowerArgs.CommandLineArgument.TestIsValidAndRevivable(System.String)">
            <summary>
            Tests to see if the given value would pass validation and revival.  
            </summary>
            <param name="value">the value to test</param>
            <returns>true if the value passes validation and is successfully revived, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgument.ToString">
            <summary>
            Gets the string representation of this argument.
            </summary>
            <returns>the string representation of this argument.</returns>
        </member>
        <member name="T:PowerArgs.CommandLineArgumentsDefinition">
            <summary>
            This is the root class used to define a program's command line arguments.  You can start with an empty definition and 
            programatically add arguments or you can start from a Type that you have defined and have the definition inferred from it.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.ExeName">
            <summary>
            Gets or sets the ExeName for this command line argument definition's program.  If not specified the entry assembly's file name
            is used, without the file extension.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Copyright">
            <summary>
            An optional copyright field
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.ProductName">
            <summary>
            An optional product name field
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.ProductVersion">
            <summary>
            An optional product version field
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Description">
            <summary>
            Gets the description from ArgDescriptionMetadata if it exists, or empty string if it does not.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasDescription">
            <summary>
            Gets whether or not this program has a description
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasCopyright">
            <summary>
            Gets whether or not this program has the Copyright field set
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasProductName">
            <summary>
            Gets whether or not this program has a product name set
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasProductVersion">
            <summary>
            Gets whether or not this program has a product name set
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasGlobalArguments">
            <summary>
            Returns true if there is at least 1 global argument, false otherwise
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasActions">
            <summary>
            Returns true if there is at least 1 action, false otherwise
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.UsageSummary">
            <summary>
            Creates a usage summary string that takes into account actions, positional argument, etc.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.UsageSummaryHTMLEncoded">
            <summary>
            Creates a usage summary string that takes into account actions, positional argument, etc. where the
            brackets are html encoded
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.IsNonInteractive">
            <summary>
            When set to true, TabCompletion is completely disabled and required fields will ignore the PromptIfMissing flag.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.ArgumentScaffoldType">
            <summary>
            The type that was used to generate this definition.  This will only be populated if you use the constructor that takes in a type and the definition is inferred.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Arguments">
            <summary>
            The command line arguments that are global to this definition.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.AllGlobalAndActionArguments">
            <summary>
            Gets all global command line arguments as well as all arguments of any actions in this definition
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Hooks">
            <summary>
            Global hooks that can execute all hook override methods except those that target a particular argument.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Actions">
            <summary>
            Actions that are defined for this definition.  If you have at least one action then the end user must specify the action as the first argument to your program.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Metadata">
            <summary>
            Arbitrary metadata that has been added to the definition
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasExamples">
            <summary>
            Returns true if there is at least 1 example registered for this definition
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.Examples">
            <summary>
            Examples that show users how to use your program.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.ExceptionBehavior">
            <summary>
            Determines how end user errors should be handled by the parser.  By default all exceptions flow through to your program.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.SpecifiedAction">
            <summary>
            If your definition declares actions and has been successfully parsed then this property will be populated
            with the action that the end user specified.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.HasSpecifiedAction">
            <summary>
            Returns true if this definition has been processed and an action was specified
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.UnexpectedExplicitArguments">
            <summary>
            Gets any named arguments that were present on the command line, but did not match any arguments defined
            by the definition.  This is only valid if the AllowUnexpectedArgs metadata is present.
            </summary>
        </member>
        <member name="P:PowerArgs.CommandLineArgumentsDefinition.UnexpectedImplicitArguments">
            <summary>
            Gets any positional arguments that were present on the command line, but did not match any arguments defined
            by the definition.  This is only valid if the AllowUnexpectedArgs metadata is present.
            </summary>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.#ctor">
            <summary>
            Creates an empty command line arguments definition.
            </summary>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.#ctor(System.Type)">
            <summary>
            Creates a command line arguments definition and infers things like Arguments, Actions, etc. from the type's metadata.
            </summary>
            <param name="t">The argument scaffold type used to infer the definition</param>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.FindMatchingArgument(System.String,System.Boolean)">
            <summary>
            Finds the first CommandLineArgument that matches the given key.
            </summary>
            <param name="key">The key as if it was typed in on the command line.  This can also be an alias. </param>
            <param name="throwIfMoreThanOneMatch">If set to true then this method will throw and InvalidArgDeginitionException if more than 1 match is found</param>
            <returns>The first argument that matches the key.</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.FindMatchingAction(System.String,System.Boolean)">
            <summary>
            Finds the first CommandLineAction that matches the given key
            </summary>
            <param name="key">The key as if it was typed in on the command line.  This can also be an alias. </param>
            <param name="throwIfMoreThanOneMatch">If set to true then this method will throw and InvalidArgDeginitionException if more than 1 match is found</param>
            <returns>The first action that matches the key.</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.CreateVariableResolver">
            <summary>
            Gives you an object that you can use to tell if a particular argument was specified on the command line.
            </summary>
            <returns>object that you can use to tell if a particular argument was specified on the command line</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.FindArgumentByPosition(System.Int32,System.String)">
            <summary>
            Finds the command line argument that is allowed to be specified in the given position (zero based). You can also
            pass an action name if you know the context of a targeted action.
            </summary>
            <param name="position">the position of the argument</param>
            <param name="action">optionally specify the name of an action which may also have positional arguments defined</param>
            <returns>a matching CommandLineArgument or none if there was no match</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.ToString">
            <summary>
            Gets a basic string representation of the definition.
            </summary>
            <returns>a basic string representation of the definition</returns>
        </member>
        <member name="M:PowerArgs.CommandLineArgumentsDefinition.Clean">
            <summary>
            Resets all portions of the model that may have side effects from being run through the 
            argument processor.  
            </summary>
        </member>
        <member name="T:PowerArgs.Query">
            <summary>
            A hook you can use to easily query a data source.  See an example here: https://github.com/adamabdelhamed/PowerArgs#data-source-queries
            </summary>
        </member>
        <member name="P:PowerArgs.Query.DataSourceType">
            <summary>
            Your data source implementation.  The query will create a new instance of this type and use a property
            that matches the property name of the PowerArgs property this attribute is on in order to get the data.
            </summary>
        </member>
        <member name="M:PowerArgs.Query.#ctor(System.Type,System.String[])">
            <summary>
            Creates a new query hook given a data source type and optional reference assemblies.
            </summary>
            <param name="dataSourceType">Your data source implementation. he query will create a new instance of this type and use a property that matches the property name of the PowerArgs property this attribute is on in order to get the data.</param>
            <param name="referencedAssemblies">The names (if in the GAC) or full paths to assemblies you would like to include.  We will automatically add dlls in your bin folder.</param>
        </member>
        <member name="M:PowerArgs.Query.AfterPopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            After PowerArgs does most of its work this hook looks for string properties on the parsed object called Skip, Take, 
            Where, OrderBy, and OrderByDescending.  These properties are used to construct a linq query that is dynamically compiled
            and executed against the provided data source.
            </summary>
            <param name="context">The context used to detect the query parameters.</param>
        </member>
        <member name="T:PowerArgs.SecureStringArgument">
            <summary>
            A PowerArgs argument type that can be used to accept user input without that input appearing on the command line.
            It uses secure strings under the hood.
            </summary>
        </member>
        <member name="P:PowerArgs.SecureStringArgument.SecureString">
            <summary>
            The secure string value.  The first time your code accesses this property is when the user will be presented with
            the secure input prompt.
            </summary>
        </member>
        <member name="M:PowerArgs.SecureStringArgument.ConvertToNonsecureString">
            <summary>
            Converts the underlying secure string to a regular string.
            </summary>
            <returns>A normal string representation of the user's input.</returns>
        </member>
        <member name="T:PowerArgs.ArgumentAwareTabCompletionSource">
            <summary>
            An abstract class that can be used to implement tab completion logic that is specific to a given argument.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgumentAwareTabCompletionSource.TryComplete(System.Boolean,System.String,System.String,System.String@)">
            <summary>
            Internal implementation that determines whether or not the context matches the target command line argument
            </summary>
            <param name="shift">true if the shift key was pressed along with the tab key</param>
            <param name="context">the completed token that appeared on the command line before the current, incomplete token that's being tabbed through</param>
            <param name="soFar">the incomplete token</param>
            <param name="completion">the completion to populate</param>
            <returns>true if completion was successful, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ArgumentAwareTabCompletionSource.TryComplete(System.Boolean,PowerArgs.CommandLineArgument,System.String,System.String@)">
            <summary>
            The abstract method that should be implemented to perform some tab completion logic
            </summary>
            <param name="shift">true if the shift key was pressed along with the tab key</param>
            <param name="target">the command line argument that the soFar token is going to apply to</param>
            <param name="soFar">the incomplete token</param>
            <param name="completion">the completion to populate</param>
            <returns>true if completion was successful, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ArgumentAwareTabCompletionSource.TryComplete(System.Boolean,System.String,System.String@)">
            <summary>
            Not implemented
            </summary>
            <param name="shift">Not implemented</param>
            <param name="soFar">Not implemented</param>
            <param name="completion">Not implemented</param>
            <returns>throws NotImplementedException</returns>
        </member>
        <member name="T:PowerArgs.CycledTabCompletionManager">
            <summary>
            This helper class can be leveraged when implementing custom tab completion logic.  It knows how to cycle through multple
            candidates and support tabbing forward and shift/tabbing backwards.  You just pass values from the tab completion methods
            and then provide an evaluation function that knows how to get the list of possible matches.
            </summary>
        </member>
        <member name="P:PowerArgs.CycledTabCompletionManager.MinCharsBeforeCyclingBegins">
            <summary>
            If the value of soFar is a string that's less than this value then no completion will be returned.
            </summary>
        </member>
        <member name="M:PowerArgs.CycledTabCompletionManager.Cycle(System.Boolean,System.String@,System.Func{System.Collections.Generic.List{System.String}},System.String@)">
            <summary>
            Cycles through the candidates provided by the given evaluation function using the arguments passed through from
            the tab completion system.
            </summary>
            <param name="shift">You should pass true if the shift key was pressed during the tab</param>
            <param name="soFar">You should pass through a reference to the soFar value that was sent by the tab completion system</param>
            <param name="evaluation">A function that looks at 'soFar' and determines which values might be a match</param>
            <param name="completion">The completion to populate if the conditions all work out</param>
            <returns>True if completion was populated, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.GroupedRegexArg">
            <summary>
            An abstract class that lets you create custom argument types that match a regular expression.  The 
            class also makes it easy to extract named groups from the regular expression for use by your application.
            </summary>
        </member>
        <member name="F:PowerArgs.GroupedRegexArg.exactMatch">
            <summary>
            The match that exactly matches the given regular expression
            </summary>
        </member>
        <member name="M:PowerArgs.GroupedRegexArg.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new grouped regular expression argument instance.
            </summary>
            <param name="regex">The regular expression to enforce</param>
            <param name="input">The user input that was provided</param>
            <param name="errorMessage">An error message to show in the case of a non match</param>
        </member>
        <member name="M:PowerArgs.GroupedRegexArg.Group(System.String,System.String)">
            <summary>
            A helper function you can use to group a particular regular expression.
            </summary>
            <param name="regex">Your regular expression that you would like to put in a group.</param>
            <param name="groupName">The name of the group that you can use to extract the group value later.</param>
            <returns></returns>
        </member>
        <member name="P:PowerArgs.GroupedRegexArg.Item(System.String)">
            <summary>
            Gets the value of the regex group from the exact match.
            </summary>
            <param name="groupName">The name of the group to lookup</param>
            <returns></returns>
        </member>
        <member name="P:PowerArgs.GroupedRegexArg.Item(System.Int32)">
            <summary>
            Gets the value of the regex group from the exact match.
            </summary>
            <param name="groupNumber">The index of the group to lookup</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.MultiTabCompletionSource">
            <summary>
            An aggregate tab completion source that cycles through it's inner sources looking for matches.
            </summary>
        </member>
        <member name="M:PowerArgs.MultiTabCompletionSource.#ctor(PowerArgs.ITabCompletionSource[])">
            <summary>
            Create a new MultiTabCompletionSource given an array of sources.
            </summary>
            <param name="sources">The sources to wrap</param>
        </member>
        <member name="M:PowerArgs.MultiTabCompletionSource.#ctor(System.Collections.Generic.IEnumerable{PowerArgs.ITabCompletionSource})">
            <summary>
            Create a new MultiTabCompletionSource given an IEnumerable of sources.
            </summary>
            <param name="sources">The sources to wrap</param>
        </member>
        <member name="M:PowerArgs.MultiTabCompletionSource.TryComplete(System.Boolean,System.String,System.String@)">
            <summary>
            Not implemented since this type implements ITabCompletionSourceWithContext
            </summary>
            <param name="shift"></param>
            <param name="soFar"></param>
            <param name="completion"></param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.MultiTabCompletionSource.TryComplete(System.Boolean,System.String,System.String,System.String@)">
            <summary>
            Iterates over the wrapped sources looking for a match
            </summary>
            <param name="shift">Indicates if shift was being pressed</param>
            <param name="soFar">The text token that the user has typed before pressing tab.</param>
            <param name="context"></param>
            <param name="completion">The variable that you should assign the completed string to if you find a match.</param>
            <returns></returns>
        </member>
        <member name="T:PowerArgs.SimpleTabCompletionSource">
            <summary>
            A simple tab completion source implementation that looks for matches over a set of pre-determined strings.
            </summary>
        </member>
        <member name="P:PowerArgs.SimpleTabCompletionSource.MinCharsBeforeCyclingBegins">
            <summary>
            Require that the user type this number of characters before the source starts cycling through ambiguous matches.  The default is 3.
            </summary>
        </member>
        <member name="M:PowerArgs.SimpleTabCompletionSource.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new completion source given an enumeration of string candidates
            </summary>
            <param name="candidates"></param>
        </member>
        <member name="M:PowerArgs.SimpleTabCompletionSource.#ctor(System.Func{System.Collections.Generic.IEnumerable{System.String}})">
            <summary>
            Creates a simple tab completion source given a function used to evaluate the candidates.
            </summary>
            <param name="candidateFunction">The function used to evaluate the completions where the input is a string parameter that represents the incomplete token</param>
        </member>
        <member name="M:PowerArgs.SimpleTabCompletionSource.TryComplete(System.Boolean,System.String,System.String@)">
            <summary>
            Not implemented since this type implements ITabCompletionSourceWithContext
            </summary>
            <param name="shift"></param>
            <param name="soFar"></param>
            <param name="completion"></param>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.SimpleTabCompletionSource.TryComplete(System.Boolean,System.String,System.String,System.String@)">
            <summary>
            Iterates through the candidates to try to find a match.  If there are multiple possible matches it 
            supports cycling through tem as the user continually presses tab.
            </summary>
            <param name="shift">Indicates if shift was being pressed</param>
            <param name="soFar">The text token that the user has typed before pressing tab.</param>
            <param name="context"></param>
            <param name="completion">The variable that you should assign the completed string to if you find a match.</param>
            <returns>true if the tab completion was successful, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.SimpleTabCompletionSource.TryComplete(PowerArgs.TabCompletionContext,System.String@)">
            <summary>
            Iterates through the candidates to try to find a match.  If there are multiple possible matches it 
            supports cycling through tem as the user continually presses tab.
            </summary>
            <param name="context">Information about the tab completion</param>
            <param name="completion">The variable that you should assign the completed string to if you find a match.</param>
            <returns>true if the tab completion was successful, false otherwise</returns>
        </member>
        <member name="T:PowerArgs.USPhoneNumber">
            <summary>
            An example of a custom type that uses regular expressions to extract values from the command line
            and implements an ArgReviver to transform the text input into a complex type.
            This class represents a US phone number.
            </summary>
        </member>
        <member name="P:PowerArgs.USPhoneNumber.AreaCode">
            <summary>
            The three digit area code of the phone number.
            </summary>
        </member>
        <member name="P:PowerArgs.USPhoneNumber.FirstDigits">
            <summary>
            The three digit first segment of the phone number
            </summary>
        </member>
        <member name="P:PowerArgs.USPhoneNumber.SecondDigits">
            <summary>
            The four digit second segment of the phone number.
            </summary>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.#ctor(System.String)">
            <summary>
            Creates a phone number object from a string
            </summary>
            <param name="phoneNumber"></param>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.ToString">
            <summary>
            Gets the default string representation of the phone number in the format '1-(aaa)-bbb-cccc'.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.ToString(System.String)">
            <summary>
            Formats the phone number as a string.  
            </summary>
            <param name="format">Use '{aaa}' for the area code, use {bbb} for the first grouping, and use {cccc} for the second grouping.</param>
            <returns>A formatted phone number string</returns>
        </member>
        <member name="M:PowerArgs.USPhoneNumber.Revive(System.String,System.String)">
            <summary>
            Custom PowerArgs reviver that converts a string parameter into a custom phone number
            </summary>
            <param name="key">The name of the argument (not used)</param>
            <param name="val">The value specified on the command line</param>
            <returns>A USPhoneNumber object based on the user input</returns>
        </member>
        <member name="T:PowerArgs.ArgumentAwareTabCompletionAttribute">
            <summary>
            An attribute that can be placed on an argument property that adds argument aware tab completion for users who press the tab key while
            in the context of the targeted argument.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgumentAwareTabCompletionAttribute.CompletionSourceType">
            <summary>
            The tab completion source type that will be used to implement tab completion
            </summary>
        </member>
        <member name="M:PowerArgs.ArgumentAwareTabCompletionAttribute.#ctor(System.Type)">
            <summary>
            Creates a new ArgumentAwareTabCompletionAttribute given a completion source type
            </summary>
            <param name="completionSourceType"></param>
        </member>
        <member name="T:PowerArgs.TabCompletion">
            <summary>
            A hook that takes over the command line and provides tab completion for known strings when the user presses
            the tab key.
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.CompletionSourceType">
            <summary>
            Gets or sets the type to be used for global tab completion.  The type should implement ITabCompletionSource or ISmartTabCompletionSource
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.HighlighterConfiguratorType">
            <summary>
            Gets or sets the type to be used to dynamically configure syntax highlighting.  The type must implement IHighlighterConfigurator.
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.Indicator">
            <summary>
            When this indicator is the only argument the user specifies that triggers the hook to enhance the command prompt.  By default, the indicator is the empty string.
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.HistoryToSave">
            <summary>
            If this is > 0 then PowerArgs will save this many previous executions of the command line to your application data folder.
            Users can then access the history by pressing arrow up or down from the enhanced command prompt.
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.HistoryFileName">
            <summary>
            The location of the history file name (AppData/PowerArgs/EXE_NAME.TabCompletionHistory.txt
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.ExeName">
            <summary>
            The name of your program (leave null and PowerArgs will try to detect it automatically)
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.REPL">
            <summary>
            If true, then you must use Args.InvokeAction or Args.InvokeMain instead of Args.Parse.  Your user
            will get an interactive prompt that loops until they specify the REPLExitIndicator.
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.REPLExitIndicator">
            <summary>
            The string users can specify in order to exit the REPL (defaults to string.Empty)
            </summary>
        </member>
        <member name="P:PowerArgs.TabCompletion.REPLWelcomeMessage">
            <summary>
            The message to display to the user when the REPL starts.  The default is Type a command or '{{Indicator}}' to exit.
            You can customize this message and use {{Indicator}} for the placeholder for your exit indicator.
            </summary>
        </member>
        <member name="M:PowerArgs.TabCompletion.#ctor(System.String)">
            <summary>
            Creates a new tab completion hook.
            </summary>
            <param name="indicator">When this indicator is the only argument the user specifies that triggers the hook to enhance the command prompt.  By default, the indicator is the empty string.</param>
        </member>
        <member name="M:PowerArgs.TabCompletion.#ctor(System.Type,System.String)">
            <summary>
            Creates a new tab completion hook given a custom tab completion implementation.
            </summary>
            <param name="completionSource">A type that implements ITabCompletionSource such as SimpleTabCompletionSource</param>
            <param name="indicator">When this indicator is the only argument the user specifies that triggers the hook to enhance the command prompt.  By default, the indicator is the empty string.</param>
        </member>
        <member name="M:PowerArgs.TabCompletion.BeforeParse(PowerArgs.ArgHook.HookContext)">
            <summary>
            Before PowerArgs parses the args, this hook inspects the command line for the indicator and if found 
            takes over the command line and provides tab completion.
            </summary>
            <param name="context">The context used to inspect the command line arguments.</param>
        </member>
        <member name="M:PowerArgs.TabCompletion.ClearHistory">
            <summary>
            Clears all history saved on disk
            </summary>
        </member>
        <member name="T:PowerArgs.ArgCantBeCombinedWith">
            <summary>
            Argument metadata that lets you declare that a particular argument is not allowed if one or more other arguments are specified by the user.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgCantBeCombinedWith.ExpressionText">
            <summary>
            The expression text that was passed into the constructor.  This can either be an alias argument or a boolean expression of arguments (e.g. Argument1 | Argument2). Valid operators are
            and '&amp;', or '|', and not '!'.  Grouping with parentheses is also supported.  Example: "(Argument1 &amp; Argumrnt2) | Argument3".
            </summary>
        </member>
        <member name="M:PowerArgs.ArgCantBeCombinedWith.#ctor(System.String)">
            <summary>
            Creates a new ArgCantBeCombinedWith hook given an expression. This can either be an alias argument or a boolean expression of arguments (e.g. Argument1 | Argument2). Valid operators are
            and '&amp;', or '|', and not '!'.  Grouping with parentheses is also supported.  Example: "(Argument1 &amp; Argumrnt2) | Argument3".
            If the expression evaluates to true after all arguments have been populated then an UnexpectedArgumentException is thrown.
            </summary>
            <param name="expression">This can either be an alias argument or a boolean expression of arguments (e.g. Argument1 | Argument2). Valid operators are
            and '&amp;', or '|', and not '!'.  Grouping with parentheses is also supported.  Example: "(Argument1 &amp; Argumrnt2) | Argument3".</param>
        </member>
        <member name="M:PowerArgs.ArgCantBeCombinedWith.IsCurrentArgumentAllowed(PowerArgs.ArgHook.HookContext)">
            <summary>
            Determines if the current argument is allowed to be populated based on which other arguments are present and based on the expression passed to the constructor.
            </summary>
            <param name="context">The current PowerArgs processing context</param>
            <returns>True if this argument can be specified, false otherwise</returns>
        </member>
        <member name="M:PowerArgs.ArgCantBeCombinedWith.AfterPopulateProperties(PowerArgs.ArgHook.HookContext)">
            <summary>
            Checks to see if the current argument is allowed to have a value based on which other arguments are present and based on the expression
            passed to the constructor.  If it's not allowed and has been specified then an UnexpectedArgException is thrown.
            </summary>
            <param name="context">The current PowerArgs processing context</param>
        </member>
        <member name="T:PowerArgs.ArgExistingDirectory">
            <summary>
            Validates that if the user specifies a value for a property that the value represents a directory that exists
            as determined by System.IO.Directory.Exists(directory).
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExistingDirectory.Validate(System.String,System.String@)">
            <summary>
            Validates that the given directory exists and cleans up the argument so that the application has access
            to the full path.
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line</param>
        </member>
        <member name="T:PowerArgs.ArgExistingFile">
            <summary>
            Validates that if the user specifies a value for a property that the value represents a file that exists
            as determined by System.IO.File.Exists(file).
            </summary>
        </member>
        <member name="M:PowerArgs.ArgExistingFile.Validate(System.String,System.String@)">
            <summary>
            Validates that the given file exists and cleans up the argument so that the application has access
            to the full path.
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line</param>
        </member>
        <member name="T:PowerArgs.ArgRange">
            <summary>
            Validates that the value is a number between the min and max (both inclusive) specified
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRange.MaxIsExclusive">
            <summary>
            Set to true if your max is exclusive.  This value is false by default.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRange.#ctor(System.Double,System.Double)">
            <summary>
             Creates a new ArgRange validator.
            </summary>
            <param name="min">The minimum value (inclusive)</param>
            <param name="max">The maximum value (inclusive by default, set MaxIsExclusive to true to override)</param>
        </member>
        <member name="M:PowerArgs.ArgRange.Validate(System.String,System.String@)">
            <summary>
            Validates that the value is a number between the min and max (both inclusive) specifie
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line</param>
        </member>
        <member name="T:PowerArgs.ArgRegex">
            <summary>
            Performs regular expression validation on a property.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgRegex.regex">
            <summary>
            The regular expression to match
            </summary>
        </member>
        <member name="F:PowerArgs.ArgRegex.errorMessage">
            <summary>
            A prefix for the error message to show in the case of a match.
            </summary>
        </member>
        <member name="F:PowerArgs.ArgRegex.exactMatch">
            <summary>
            The exact match that was found.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRegex.#ctor(System.String,System.String)">
            <summary>
            Creates a new ArgRegex validator.
            </summary>
            <param name="regex">The regular expression that requires an exact match to be valid</param>
            <param name="errorMessage">A prefix for the error message to show in the case of a match.</param>
        </member>
        <member name="M:PowerArgs.ArgRegex.Validate(System.String,System.String@)">
            <summary>
            Validates that the given arg exactly matches the regular expression provided.
            </summary>
            <param name="name">the name of the property being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line.</param>
        </member>
        <member name="T:PowerArgs.ArgRequired">
            <summary>
            Validates that the user actually provided a value for the given property on the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.ImplementsValidateAlways">
            <summary>
            Determines whether or not the validator should run even if the user doesn't specify a value on the command line.
            This value is always true for this validator.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.If">
            <summary>
            A valid command line alias or boolean expression of aliases (and/or/not supported as and '&amp;', or '|', and not '!').
            When specified the target argument is only required if the referenced argument(s) were specified on the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.IfNot">
            <summary>
            A valid command line alias or boolean expression of aliases (and/or/not supported as and '&amp;', or '|', and not '!').
            When specified the target argument is only required if the referenced argument(s) were not specified on the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.IsConditionallyRequired">
            <summary>
            Determines if this metadata represents an argument conditionionally required.  This will be true if you've set the If or the IfNot property.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.TabCompletionHandlerType">
            <summary>
            Gets or sets the type to be used for tab completion when prompting for a missing, required argument.  The type must implement ITabCompletionHandler
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.HighlighterConfiguratorType">
            <summary>
            Gets or sets the type to use inject custom syntax highlighting when prompting for a missing, required argument.  The type must implement IHighlighterConfigurator
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRequired.#ctor">
            <summary>
            Creates a new ArgRequired attribute.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequired.PromptIfMissing">
            <summary>
            If you set this to true and the user didn't specify a value then the command line will prompt the user for the value.
            </summary>
        </member>
        <member name="M:PowerArgs.ArgRequired.ValidateAlways(PowerArgs.CommandLineArgument,System.String@)">
            <summary>
            Validates that the user actually specified a value and optionally prompts them when it is missing.
            </summary>
            <param name="argument">The argument being populated.  This validator doesn't do anything with it.</param>
            <param name="arg">The value specified on the command line or null if it wasn't specified</param>
        </member>
        <member name="P:PowerArgs.ArgRequiredConditionalHook.TabCompletionHandlerType">
            <summary>
            Gets or sets the type to be used for tab completion when prompting for a missing, required argument.  The type must implement ITabCompletionHandler
            </summary>
        </member>
        <member name="P:PowerArgs.ArgRequiredConditionalHook.HighlighterConfiguratorType">
            <summary>
            Gets or sets the type to use inject custom syntax highlighting when prompting for a missing, required argument.  The type must implement IHighlighterConfigurator
            </summary>
        </member>
        <member name="T:PowerArgs.ArgValidator">
            <summary>
            An abstract class that all validators should extend to validate user input from the command line.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgValidator.Priority">
            <summary>
            Determines the order in which validators are executed.  Higher numbers execute first.
            </summary>
        </member>
        <member name="P:PowerArgs.ArgValidator.ImplementsValidateAlways">
            <summary>
            If implemented in a derived class then ValidateAlways will be called for each property,
            even if that property wasn't specified by the user on the command line.  In this case the value
            will always be null.  This is useful for implementing validators such as [ArgRequired].
            
            By default, the Validate(string,ref string) method is called unless a validator opts into ValidateAlways
            </summary>
        </member>
        <member name="M:PowerArgs.ArgValidator.Validate(System.String,System.String@)">
            <summary>
            Most validators should just override this method. It ONLY gets called if the user specified the 
            given argument on the command line, meaning you will never get a null for 'arg'.
            
            If you want your validator to run even if the user did not specify the argument on the command line
            (for example if you were building something like [ArgRequired] then you should do 3 things.
            
            1 - Override the boolean ImplementsValidateAlways property so that it returns true
            2 - Override the ValidateAlways() method instead
            3 - Don't override the Validate() method since it will no longer be called
            
            </summary>
            <param name="name"></param>
            <param name="arg">The value specified on the command line.  If the user specified the property name, but not a value then arg will equal string.Empty.  The value will never be null.</param>
        </member>
        <member name="M:PowerArgs.ArgValidator.ValidateAlways(System.Reflection.PropertyInfo,System.String@)">
             <summary>
             Always validates the given property, even if it was not specified by the user (arg will be null in this case).
             If you override this method then you should also override ImplementsValidateAlways so it returns true.
            </summary>
             <param name="property">The property that the attribute was placed on.</param>
             <param name="arg">The value specified on the command line or null if the user didn't actually specify a value for the property.  If the user specified the property name, but not a value then arg will equal string.Empty</param>
        </member>
        <member name="M:PowerArgs.ArgValidator.ValidateAlways(PowerArgs.CommandLineArgument,System.String@)">
             <summary>
             Always validates the given argument, even if it was not specified by the user (arg will be null in this case).
             If you override this method then you should also override ImplementsValidateAlways so it returns true.
            </summary>
             <param name="argument">The argument that the attribute was placed on.</param>
             <param name="arg">The value specified on the command line or null if the user didn't actually specify a value for the argument.  If the user specified the argument name, but not a value then arg will equal string.Empty</param>
        </member>
    </members>
</doc>
